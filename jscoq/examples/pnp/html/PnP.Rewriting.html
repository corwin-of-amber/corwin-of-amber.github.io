<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../js/clean.css" rel="stylesheet" type="text/css" />
<title>PnP.Rewriting</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library PnP.Rewriting</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">


<div class="paragraph"> </div>

In the previous chapter we have seen how main connectives from
propositional logic are encoded in Coq. However, the mathematical
reasoning only by means of propositional logic is still quite
limited. In particular, by this moment we are still unable to state
what does it mean for two objects to be <i>equal</i>. In this chapter we
are going to see how equality can be implemented in Coq. Moreover, the
statement "<i>x</i> is equal to <i>y</i>" automatically gives us a way to
replace <i>y</i> by <i>x</i> and vice versa in the process of reasoning,
therefore implementing a discipline of <i>rewriting</i>---one of the key
ingredients of the mathematical proof. Later in the chapter, we will see how
rewriting by equality is just a particular case of a general proof
pattern, which allows one to define arbitrary <i>rewriting rules</i> by
exploiting Coq's mechanism of <i>indexed type families</i>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">mathcomp</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">ssreflect</span> <span class="id" title="library">ssrnat</span> <span class="id" title="library">ssrbool</span> <span class="id" title="library">eqtype</span>.<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="keyword">Strict</span> <span class="id" title="keyword">Implicit</span>.<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="keyword">Printing</span> <span class="id" title="keyword">Implicit</span> <span class="id" title="var">Defensive</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab32"></a><h1 class="section">Propositional equality in Coq</h1>



<div class="paragraph"> </div>

Let us begin by exploring the definition of the equality predicate "<span class="inlinecode"><span class="id" title="var">_</span></span>
<span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">_</span></span>".

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "_ = _".<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">"x = y" := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a>    : <span class="id" title="var">type_scope</span>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>) : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <span class="id" title="keyword">Prop</span> :=  <span class="id" title="lemma">eq_refl</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>



<div class="paragraph"> </div>

As we can see, the equality is just yet another inductive predicate,
similar to the logical connectives we've seen in
. However, there are differences, which are of
importance. First, equality as a predicate is <i>parametrized</i>
 over two arguments: a <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> of an
unspecified universe (so, it can be <span class="inlinecode"><span class="id" title="keyword">Set</span></span>, <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> or any of the higher
universes) and an element <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>. There is nothing
particularly new here: we have seen parametrized inductive predicates
before, for instance, conjunction and disjunction in
. The novel part of this definition is
what comes after the colon trailing the parameter list. Unlike all
previously seen logical connectives, the equality predicate has type
<span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> in contrast to just <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. In the Coq terminology, it
means that <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a></span> is not just inductively-defined datatype, but is an
<i>indexed type family</i>. In this
particular case, it is indexed  by elements
of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>, which appears at the left of the arrow.

<div class="paragraph"> </div>





<div class="paragraph"> </div>

It is common to think of
indexed type families in Coq as of <i>generalized algebraic datatypes</i>
(GADTs), familiar from
 Haskell, and allowing one to refine the process
pattern matching basing on the type index of the scrutinee. However,
another analogy turns out to be much more useful in the Coq setting:
indexed type families in fact allow one to encode <i>rewriting
principles</i>. To understand, what the indexed datatype definition has
to do with rewriting, let us take a close look at the definition of
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a></span>. The type of its only constructor <span class="inlinecode"><span class="id" title="lemma">eq_refl</span></span> is a bit misleading,
as it looks like it is applied to two arguments: <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and ... <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>. To
disambiguate it, we shall put some parentheses, so, in fact, it should
readas

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>) : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <span class="id" title="keyword">Prop</span> :=  <span class="id" title="lemma">eq_refl</span> : (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>) <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

That is, the constructor <span class="inlinecode"><span class="id" title="lemma">eq_refl</span></span> delivers an element of type <span class="inlinecode">(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>)</span>,
whose <i>parameter</i> is some <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> (and <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a></span> is directly applied to it),
and its <i>index</i> (which comes second) is constrained to be <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> as
well. That is, case-analysing on an instance of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> in the
process of the proof construction will inevitably lead the side
condition implying that <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> actually correspond to the <i>same
object</i>. Coq will take advantage of this fact immediately, by
performing the <i>unification</i>  and substituting
all occurrences of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> in the subsequent goal with <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>.  Let us see
how it works in practice.

<div class="paragraph"> </div>

<a name="lab33"></a><h2 class="section">Case analysis on an equality witness</h2>


<div class="paragraph"> </div>

To demonstrate the actual proofs on the case analysis by equality, we
will have to perform an awkward twist: define <i>our own</i> equality
predicate. 

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">Inductive</span> <a name="Rewriting.my_eq"><span class="id" title="inductive">my_eq</span></a> (<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span> : <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) : <span class="id" title="var">A</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span> :=  <a name="Rewriting.my_eq_refl"><span class="id" title="constructor">my_eq_refl</span></a> : <a class="idref" href="PnP.Rewriting.html#my_eq"><span class="id" title="inductive">my_eq</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="ea2f0a454b8d1576afbd91440f6c0f8e"><span class="id" title="notation">&quot;</span></a>x === y" := (<a class="idref" href="PnP.Rewriting.html#Rewriting.my_eq"><span class="id" title="inductive">my_eq</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 70).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

As we can see, this definition literally repeats the Coq's standard
definition of propositional equality. The reason for the code
duplication is that Ssreflect provides a specific treatment of Coq's
standard equality predicate, so the case-analysis on its instances is
completely superseded by the powerful <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> tactics, which we will
see in  of this chapter. Alas, this
special treatment also leads to a non-standard behaviour of
case-analysis on equality. This is why, for didactical purposes, we
will have to stick with or own home-brewed definition until the end of
this section.

<div class="paragraph"> </div>

Let us now prove some interesting properties of the freshly-defined
equality. We start with symmetry of <span class="inlinecode">===</span> by formulating the
following lemma:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.my_eq_sym"><span class="id" title="lemma">my_eq_sym</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>: <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.Rewriting.html#ea2f0a454b8d1576afbd91440f6c0f8e"><span class="id" title="notation">===</span></a> <a class="idref" href="PnP.Rewriting.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.Rewriting.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.Rewriting.html#ea2f0a454b8d1576afbd91440f6c0f8e"><span class="id" title="notation">===</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

First, we perform the case analysis on the top assumption of the goal,
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">===</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">case</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> === <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

This leads to the goal, being switched from <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">===</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> to <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">===</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>, as
all occurrences of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> are now replaced by <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>, exactly as advertised.
We can now finish the proof by applying the constructor (<span class="inlinecode"><span class="id" title="tactic">apply</span>:</span>
<span class="inlinecode"><span class="id" title="var">my_refl_eq</span></span>) or simply by <span class="inlinecode"><span class="id" title="var">done</span></span>, which is powerful enough to figure
out what to apply.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Our next exercise will be to show that the predicate we have just
defined implies Leibniz equality. The proof is accomplished in one
 line by case-analysing on the equality,
which leads to the automatic replacements of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> by <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.my_eq_Leibniz"><span class="id" title="lemma">my_eq_Leibniz</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>: <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">P</span>: <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>) : <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.Rewriting.html#ea2f0a454b8d1576afbd91440f6c0f8e"><span class="id" title="notation">===</span></a> <a class="idref" href="PnP.Rewriting.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.Rewriting.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.Rewriting.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="PnP.Rewriting.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab34"></a><h2 class="section">Implementing discrimination</h2>



<div class="paragraph"> </div>

Another important application of the equality predicate family and
similar ones  are <i>proofs by discrimination</i>,
in which the contradiction is reached (i.e., the falsehood is derived)
out of the fact that two clearly non-equal elements are assumed to be
equal. The next lemma demonstrates the essence of the proof by
discrimination using the <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.my_eq"><span class="id" title="inductive">my_eq</span></a></span> predicate.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.disaster"><span class="id" title="lemma">disaster</span></a> : 2 <a class="idref" href="PnP.Rewriting.html#ea2f0a454b8d1576afbd91440f6c0f8e"><span class="id" title="notation">===</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">H</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a> : 2 === 1<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

As it is already hinted by the name of the method, the key insight in
the proofs by discrimination is to construct a function that can
distinguish between values of the type with an implicit <i>definitional
equality</i>, which relates two values if
they have identical structure. In particular, natural numbers can be compared
against each other by means of direct pattern matching, which is
decidable for them, thanks to the inductive definition. Using this
insight we define a local "discriminating" function <span class="inlinecode"><span class="id" title="var">D</span></span> using the
Ssreflect's enhanced <span class="inlinecode"><span class="id" title="tactic">pose</span></span>  tactic:

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="tactic">pose</span> <span class="id" title="var">D</span> <span class="id" title="var">x</span> := <span class="id" title="keyword">if</span> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">is</span> 2 <span class="id" title="keyword">then</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a> : 2 === 1<br/>
&nbsp;&nbsp;<span class="id" title="var">D</span> := <span class="id" title="keyword">fun</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 0 ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1 ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2 ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> (<a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> (<a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> <span class="id" title="var">_</span>)) ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">end</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> → <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Now, proving <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">1</span> is <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> can be accomplished by simple executing
<span class="inlinecode"><span class="id" title="var">D</span></span> with appropriate arguments (recall that <span class="inlinecode"><span class="id" title="var">D</span></span> is an
always-terminating function, whose result is a computable value). That
Ssreflect's tactic <span class="inlinecode"><span class="id" title="var">have</span></span> allows to declare the local
fact, which can be then proved in-place by simple computation (which
is performed via <span class="inlinecode"><span class="id" title="tactic">by</span></span> <span class="inlinecode">[]</span>).

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">have</span> <span class="id" title="var">D1</span>: <span class="id" title="var">D</span> 1.<br/>
<span class="id" title="tactic">by</span> [].<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a> : 2 === 1<br/>
&nbsp;&nbsp;<span class="id" title="var">D</span> := ...<br/>
&nbsp;&nbsp;<span class="id" title="var">D1</span> : <span class="id" title="var">D</span> 1<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Next we "push" <span class="inlinecode"><span class="id" title="var">D1</span></span> and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> back to the goal (using the <span class="inlinecode">:</span> tactical),
and case-analyse on the top assumption <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span>. Notice that the semantics
of <span class="inlinecode">:</span>  is such that it first performs a series of
"pushings" and then runs the tactic on the left of itself (i.e.,
<span class="inlinecode"><span class="id" title="tactic">case</span></span>).

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="tactic">case</span>: <span class="id" title="var">H</span> <span class="id" title="var">D1</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">D</span> := ...<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">D</span> 2 → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Now, we got what we have needed: the proof of the falsehood! Thanks to
the equality-provided substitution, <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">1</span> turned into <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">2</span>, and the
only thing that remains now is to <i>evaluate</i> it.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>=&gt;/=.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The tactical <span class="inlinecode">/=</span>, coming after <span class="inlinecode">⇒</span> runs all possible
simplifications on the result obtained by the tactics, preceding <span class="inlinecode">⇒</span>,
finishing the proof.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Let us provide a bit more explanation how did it happen that we
managed to derive the falsehood in the process of the proof. The
discrimination function <span class="inlinecode"><span class="id" title="var">D</span></span> is a function from <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> to <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, and,
indeed, it can return <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> and <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>, so it contains no
contradictions by itself. We also managed to prove easily a trivial
proposition <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">1</span>, which is just <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span>, so it's derivable. The
genuine twist happened when we managed to turn the assumption <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">1</span>
(which was <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span>) to <span class="inlinecode"><span class="id" title="var">D</span></span> <span class="inlinecode">2</span> (which is <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>). This was only possible
because of the assumed equality <span class="inlinecode">2</span> <span class="inlinecode">===</span> <span class="inlinecode">1</span>, which contained the
"falsehood" from the very beginning and forced Coq to substitute the
occurrence of <span class="inlinecode">1</span> in the goal by <span class="inlinecode">2</span>, so the discrimination function
in the assumption finished the job.

<div class="paragraph"> </div>


Let us change the statement of a previous lemma for a little bit:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.disaster2"><span class="id" title="lemma">disaster2</span></a> : 1 <a class="idref" href="PnP.Rewriting.html#ea2f0a454b8d1576afbd91440f6c0f8e"><span class="id" title="notation">===</span></a> 2 <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">

Now, try to prove it using the same scheme. What goes wrong and how to
fix it?

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab35"></a><h2 class="section">Reasoning with Coq's standard equality</h2>


<div class="paragraph"> </div>

Now we know what drives the reasoning by equality and discrimination,
so let us forget about the home-brewed predicate <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.my_eq"><span class="id" title="inductive">my_eq</span></a></span> and use the
standard equality instead. Happily, the discrimination pattern we used
to implement "by hand" now is handled by Coq/Ssreflect automatically,
so the trivially false equalities deliver the proofs right away by
simply typing <span class="inlinecode"><span class="id" title="var">done</span></span>. 

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.disaster3"><span class="id" title="lemma">disaster3</span></a>: 2 <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="var">done</span>. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Moreover, the case-analysing on the standard equality now comes in the
form of the powerful <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> tactics, which takes the reasoning to
the whole new level and is a subject of the next section.

<div class="paragraph"> </div>

<a name="lab36"></a><h1 class="section">Proofs by rewriting </h1>


<div class="paragraph"> </div>

The vast majority of the steps when constructing real-life proofs in
Coq are <i>rewriting</i> steps. The general flow of the interactive proof
(considered in more detail in ) is
typically targeted on formulating and proving small auxiliary
hypotheses about equalities in the forward-style reasoning and then
exploiting the derived equalities by means of rewriting in the goal
and, occasionally, other assumptions in the context. All rewriting
machinery is handled by Ssreflect's enhanced <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>
tactics, and in this section we focus on its particular uses.

<div class="paragraph"> </div>

<a name="lab37"></a><h2 class="section">Unfolding definitions and in-place rewritings</h2>



<div class="paragraph"> </div>

One of the common uses of the <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> tactic is to fold/unfold
transparent definitions. In general, Coq is capable to perform the
unfoldings itself, whenever it's required. Nevertheless, manual
unfolding of a definition might help to understand the details of the
implementation, as demonstrated by the following example.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="Rewriting.double"><span class="id" title="definition">double</span></a> {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span>: <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">x</span>: <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) := <a class="idref" href="PnP.Rewriting.html#f"><span class="id" title="variable">f</span></a> (<a class="idref" href="PnP.Rewriting.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a>).<br/>

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="Rewriting.nat_iter"><span class="id" title="definition">nat_iter</span></a> (<span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) {<span class="id" title="var">A</span>} (<span class="id" title="var">f</span> : <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) (<span class="id" title="var">x</span> : <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a> :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">is</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#S"><span class="id" title="constructor">S</span></a> <span class="id" title="var">n'</span> <span class="id" title="keyword">then</span> <a class="idref" href="PnP.Rewriting.html#f"><span class="id" title="variable">f</span></a> (<a class="idref" href="PnP.Rewriting.html#nat_iter"><span class="id" title="definition">nat_iter</span></a> <span class="id" title="var">n'</span> <a class="idref" href="PnP.Rewriting.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a>) <span class="id" title="keyword">else</span> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.double2"><span class="id" title="lemma">double2</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">x</span>: <a class="idref" href="PnP.Rewriting.html#A"><span class="id" title="variable">A</span></a>) <span class="id" title="var">f</span> <span class="id" title="var">t</span>: <br/>
&nbsp;&nbsp;<a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.double"><span class="id" title="definition">double</span></a> <a class="idref" href="PnP.Rewriting.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.double"><span class="id" title="definition">double</span></a> <a class="idref" href="PnP.Rewriting.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.nat_iter"><span class="id" title="definition">nat_iter</span></a> 4 <a class="idref" href="PnP.Rewriting.html#f"><span class="id" title="variable">f</span></a> <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The first thing to do in this proof is to get rid of the auxiliary
variable <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a></span>, as it does not occur in any of the assumptions, but just
in the subsequent goal. This can be done using the following sequence
of tactics that first moves the equality assumption to the top and
then rewrites by it in the goal.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>⇒<span class="id" title="var">Et</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Et</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">Et</span> : <a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a> = <a class="idref" href="PnP.Rewriting.html#Rewriting.double"><span class="id" title="definition">double</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.Rewriting.html#Rewriting.double"><span class="id" title="definition">double</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> (<a class="idref" href="PnP.Rewriting.html#Rewriting.double"><span class="id" title="definition">double</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>) = <a class="idref" href="PnP.Rewriting.html#Rewriting.nat_iter"><span class="id" title="definition">nat_iter</span></a> 4 <a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Even though the remaining goal is simple enough to be completed by
<span class="inlinecode"><span class="id" title="var">done</span></span>, let us unfold both definition to make sure that the two terms
are indeed equal structurally. Such unfoldings can be <i>chained</i>, just
as any other rewritings.

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="tactic">rewrite</span> /<a class="idref" href="PnP.Rewriting.html#Rewriting.double"><span class="id" title="definition">double</span></a> /<a class="idref" href="PnP.Rewriting.html#Rewriting.nat_iter"><span class="id" title="definition">nat_iter</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> (<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> (<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> (<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>))) = <a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> (<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> (<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> (<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>)))
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

An alternative way to prove the same statement would be to use the
  tactical, which is usually combined with
<span class="inlinecode"><span class="id" title="tactic">move</span></span> or <span class="inlinecode"><span class="id" title="tactic">case</span></span>, but instead of moving the assumption to the top, it
makes sure that the assumption is an equality and rewrites by it.

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Restart</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>=&gt;-&gt;; <span class="id" title="tactic">rewrite</span> /<a class="idref" href="PnP.Rewriting.html#Rewriting.double"><span class="id" title="definition">double</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Notice that the tactical has a companion one ,
which performs the rewriting by an equality assumption from right to
left, in contrast to , which rewrites left to right.

<div class="paragraph"> </div>

<i>Folding</i>, the reverse operation to unfolding, is done by using <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span>
<span class="inlinecode">-/...</span>  instead of <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">/...</span>

<div class="paragraph"> </div>

<a name="lab38"></a><h2 class="section">Proofs by congruence and rewritings by lemmas</h2>


<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="Rewriting.f"><span class="id" title="definition">f</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> :=  <a class="idref" href="PnP.Rewriting.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">∀</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">x</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">y</span></a><a name="Rewriting.Unnamed_thm"><span class="id" title="definition">,</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">x</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">y</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">(</span></a><a name="Rewriting.Unnamed_thm"><span class="id" title="definition">y</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">x</span></a><a name="Rewriting.Unnamed_thm"><span class="id" title="definition">)</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">=</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">f</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">y</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">x</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">f</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">y</span></a> <a name="Rewriting.Unnamed_thm"><span class="id" title="definition">x</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">x</span> <span class="id" title="var">y</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

First, let us unfold only all occurrences of <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> in the goal.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">rewrite</span> /<a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> + <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> + (<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> + <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>) = <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> + <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> + (<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> + <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We can now reduce the goal by appealing to Ssreflect's <span class="inlinecode"><span class="id" title="var">congr</span></span>
tactics, which takes advantage of the fact that equality implies
Leibniz' equality, in particular, with respect to the addition taken
as a function, so the external addition of equal elements can be
"stripped off".

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">congr</span> (<span class="id" title="var">_</span> <span class="id" title="notation">+</span> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> + <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> = <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> + <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Now, the only thing left to prove is that the addition is commutative,
so at this point we will just make use of Ssreflect's <span class="inlinecode"><span class="id" title="library">ssrnat</span></span> library
lemma for integer addition.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="lemma">addnC</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.addnC"><span class="id" title="lemma">addnC</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">ssrfun.commutative</span> <span class="id" title="var">addn</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

At this point such signature might seem a bit cryptic, but worry not:
this is just a way to express in a generic way that the addition over
natural numbers is commutative, which can be witnessed by checking the
definition of <span class="inlinecode"><span class="id" title="var">ssrfun.commutative</span></span> predicate:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#commutative"><span class="id" title="definition">ssrfun.commutative</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">ssrfun.commutative</span> = <br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> : <span class="id" title="keyword">Type</span>) (<span class="id" title="var">op</span> : <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> → <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>) ⇒ <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a>, <span class="id" title="var">op</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> = <span class="id" title="var">op</span> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> : <span class="id" title="keyword">Type</span>, (<a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> → <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>) → <span class="id" title="keyword">Prop</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

As we can see, the definition of the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#commutative"><span class="id" title="definition">commutative</span></a></span> predicate ensures
the equality of the operation's result with its arguments, permuted,
hence <span class="inlinecode"><span class="id" title="var">op</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">op</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>. The type of the lemma <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.addnC"><span class="id" title="lemma">addnC</span></a></span> therefore
refines <span class="inlinecode"><span class="id" title="var">op</span></span> to be "<span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">_</span></span>", so, after specializing the definition
appropriately, the type of <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.addnC"><span class="id" title="lemma">addnC</span></a></span> should be read as:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.addnC"><span class="id" title="lemma">addnC</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> = <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> + <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Now, we can take advantage of this equality and rewrite by it a part
of the goal. Notice that Coq will figure out how the
universally-quantified variables should be instantiated (i.e., with
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>, respectively):

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> [<span class="id" title="var">y</span> <span class="id" title="notation">+</span> <span class="id" title="var">_</span>]<span class="id" title="lemma">addnC</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The <i>r-pattern</i>  (regex pattern) <span class="inlinecode">[<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><span class="id" title="var">_</span>]</span>,
preceding the lemma to be used for rewriting, specifies, which
subexpression of the goal should be a subject of rewriting. When
non-ambiguous, some parts of the expressions can be replaced by
wildcard  underscores <span class="inlinecode"><span class="id" title="var">_</span></span>. In this particular case,
it does not matter that much, since any single rewriting by
commutativity in any of the sums, on the left or on the right, would
make the proof to go through. However, in a more sophisticated goal it
makes sense to specify explicitly, what should be rewritten:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">∀</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">x</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">y</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">z</span></a><a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">,</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">(</span></a><a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">x</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">(</span></a><a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">y</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">z</span></a><a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">))</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">=</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">(</span></a><a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">z</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">y</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">+</span></a> <a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">x</span></a><a name="Rewriting.Unnamed_thm0"><span class="id" title="definition">)</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">rewrite</span> [<span class="id" title="var">y</span> <span class="id" title="notation">+</span> <span class="id" title="var">_</span>]<span class="id" title="lemma">addnC</span>; <span class="id" title="tactic">rewrite</span> [<span class="id" title="var">z</span> <span class="id" title="notation">+</span> <span class="id" title="var">_</span> <span class="id" title="notation">+</span> <span class="id" title="var">_</span>]<span class="id" title="lemma">addnC</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Proofs of "obvious" equalities that hold modulo, e.g., commutativity
and subjectivity, usually require several rewriting to be established,
which might be tedious.  There are ways to automate such proofs by
means of overloaded lemmas via <i>canonical structures</i>. These
techniques, hinted briefly in , are mostly
outside of the scope of this course, so we address the reader to a
number of papers, presenting the state of the art in this
direction.

<div class="paragraph"> </div>

<a name="lab39"></a><h2 class="section">Naming in subgoals and optional rewritings</h2>



<div class="paragraph"> </div>

When working with multiple cases, it is possible to "chain" the
execution of several tactics. Then, in the case of a script <span class="inlinecode"><span class="id" title="var">tac1</span>;</span>
<span class="inlinecode"><span class="id" title="var">tac2</span></span>, if the goal is replaced by several after applying <span class="inlinecode"><span class="id" title="var">tac1</span></span>, then
<span class="inlinecode"><span class="id" title="var">tac2</span></span> will be applied to <i>all</i> subgoals, generated by <span class="inlinecode"><span class="id" title="var">tac1</span></span>. For
example, let us consider a proof of the following lemma from the
standard <span class="inlinecode"><span class="id" title="library">ssrnat</span></span>  module:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.addnCA"><span class="id" title="lemma">addnCA</span></a>: <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">p</span>, <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">+</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a><span class="id" title="notation">)</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a><span class="id" title="notation">)</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">move</span>⇒<span class="id" title="var">m</span> <span class="id" title="var">n</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> + (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>) = <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + (<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The proof will proceed by induction on <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span>. We have already seen the
use of the <span class="inlinecode"><span class="id" title="tactic">case</span></span> tactics, which just performs the case
analysis. Another Ssreflect tactic <span class="inlinecode"><span class="id" title="tactic">elim</span></span>  generalizes
<span class="inlinecode"><span class="id" title="tactic">case</span></span> by applying the default induction principle (<span class="inlinecode"><span class="id" title="var">nat_ind</span></span> in this
case) with the respect to the remaining goal (that is, the predicate
<span class="inlinecode">[<span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">(<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">(<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>)]</span>) is to be proven by
induction.  The following sequence of tactics proceeds by induction on
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> with the default induction principle. It also names some of the
generated assumptions. 

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">elim</span>: <span class="id" title="var">m</span>=&gt;[ | <span class="id" title="var">m</span> <span class="id" title="var">Hm</span> ] <span class="id" title="var">p</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

In particular, the following steps are performed:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> is pushed as a top assumption of the goal;

</li>
<li> <span class="inlinecode"><span class="id" title="tactic">elim</span></span> is run, which leads to generation of the two goals;

<div class="paragraph"> </div>

<ul class="doclist">
<li> The first goal is of the shape
<br/>
<span class="inlinecode"><span class="id" title="keyword">∀</span> <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, 0 + (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>) = <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + (0 + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


</li>
<li> The second goal has the shape
<br/>
<span class="inlinecode"><span class="id" title="keyword">∀</span> <span class="id" title="var">n0</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>,<br/>
&nbsp;(<span class="id" title="keyword">∀</span> <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <span class="id" title="var">n0</span> + (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>) = <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + (<span class="id" title="var">n0</span> + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>)) →<br/>
&nbsp;<span class="id" title="keyword">∀</span> <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <span class="id" title="var">n0</span>.+1 + (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>) = <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> + (<span class="id" title="var">n0</span>.+1 + <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


</li>
</ul>

</li>
<li> The subsequent structured naming <span class="inlinecode">⇒</span> <span class="inlinecode">[</span> <span class="inlinecode">|<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode"><span class="id" title="var">Hm</span></span> <span class="inlinecode">]</span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> names zero
  assumptions in the first goal and the two top assumptions, <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> and
  <span class="inlinecode"><span class="id" title="var">Hm</span></span>, in the second goal. It then next names the assumption <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> in
  <i>both</i> goals and moves it to the top.

</li>
</ul>

<div class="paragraph"> </div>

The first goal can now be proved by multiple rewritings via the lemma
<span class="inlinecode"><span class="id" title="lemma">add0n</span></span>, stating that <span class="inlinecode">0</span> is the left unit with respect to the
addition:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> !<span class="id" title="lemma">add0n</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The second goal can be proved by a series of rewritings using the fact
about the <span class="inlinecode">(<span class="id" title="var">_</span></span> <span class="inlinecode">+</span> <span class="inlinecode">1)</span> function:

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> !<span class="id" title="lemma">addSnnS</span> -<span class="id" title="lemma">addnS</span>.<br/>

<br/>
</div>

<div class="doc">

Notice that the conclusion of the <span class="inlinecode"><span class="id" title="lemma">addnS</span></span> lemma is rewritten right-to-left.

<div class="paragraph"> </div>

The whole proof could be, however, accomplished in one line using the
<i>optional</i> rewritings. The intuitions is to <i>chain</i> the rewritings
in the goals, generated by <span class="inlinecode"><span class="id" title="tactic">elim</span></span> in a way that the unsuccessful
rewriting would not fail the whole proof construction, as they are
irrelevant for some goals anyway. This is how it can be done:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Restart</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒<span class="id" title="var">m</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">elim</span>: <span class="id" title="var">m</span>=&gt;[ | <span class="id" title="var">m</span> <span class="id" title="var">Hm</span> ] <span class="id" title="var">p</span>; <span class="id" title="tactic">rewrite</span> ?<span class="id" title="lemma">add0n</span> ?<span class="id" title="lemma">addSnnS</span> -?<span class="id" title="lemma">addnS</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Notice that the optional rewritings (e.g., <span class="inlinecode">?<span class="id" title="lemma">addSnnS</span></span>) are
performed as many times as they can be.

<div class="paragraph"> </div>

<a name="lab40"></a><h2 class="section">Selective occurrence rewritings</h2>


<div class="paragraph"> </div>

Sometimes, instead of providing an r-pattern to specialize the
rewriting, it is more convenient to specify, which particular
syntactic occurrences in the goal term
should be rewritten. This is demonstrated by the following alternative
proof of commutativity of addition from the lemma <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.addnCA"><span class="id" title="lemma">addnCA</span></a></span>, which we
have proved before:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.addnC"><span class="id" title="lemma">addnC</span></a>: <span class="id" title="keyword">∀</span> <span class="id" title="var">m</span> <span class="id" title="var">n</span>, <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒ <span class="id" title="var">m</span> <span class="id" title="var">n</span>; <span class="id" title="tactic">rewrite</span> -{1}[<span class="id" title="var">n</span>]<span class="id" title="lemma">addn0</span> <a class="idref" href="PnP.Rewriting.html#Rewriting.addnCA"><span class="id" title="lemma">addnCA</span></a> <span class="id" title="lemma">addn0</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The first rewriting with <span class="inlinecode"><span class="id" title="lemma">addn0</span></span> "adds" <span class="inlinecode">0</span> to the first occurrence of
<span class="inlinecode"><span class="id" title="lemma">addn0</span></span>, so the left-hand side of the equality becomes <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">(<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">+</span>
<span class="inlinecode">0)</span>. The next rewriting employs the lemma <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.addnCA"><span class="id" title="lemma">addnCA</span></a></span>, so we get <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode">(<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span>
<span class="inlinecode">+</span> <span class="inlinecode">0)</span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">+</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> as the goal, and the last one "removes" zero, so the
result trivially follows.

<div class="paragraph"> </div>

We conclude this section by noticing that the same rewriting machinery
is applicable not only to the goal, but also to hypotheses in the
assumption context using the <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode"><span class="id" title="var">H1</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span> <span class="inlinecode"><span class="id" title="var">H2</span></span> syntax (where <span class="inlinecode"><span class="id" title="var">H1</span></span> is
the rewriting hypothesis and <span class="inlinecode"><span class="id" title="var">H2</span></span> is a hypothesis, where the rewriting
should happen). There are many more tricks that can be done with
rewritings, and we address the reader to .

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab41"></a><h1 class="section">Indexed datatype families as rewriting rules</h1>



<div class="paragraph"> </div>

In  of this chapter we have already seen how
defining indexed datatype families 
makes it possible for Coq to provide a convenient rewriting machinery,
which is implicitly invoked by case analysis on such families' refined
types, thanks to sophisticated Coq's unification procedure.

<div class="paragraph"> </div>

Although so far this approach has been demonstrated by only one
indexed type family example---propositional equality, defined by means
of the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#eq"><span class="id" title="inductive">eq</span></a></span> family, in this section, concluding the chapter, we will
show how to define other client-specific rewriting rules. Let us start
from a motivating example in the form of an "obvious" lemma.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.huh"><span class="id" title="lemma">huh</span></a> <span class="id" title="var">n</span> <span class="id" title="var">m</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&gt;</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

From now on, we will be consistently including yet another couple of
Ssreflect modules, <span class="inlinecode"><span class="id" title="library">ssrbool</span></span> and <span class="inlinecode"><span class="id" title="library">eqtype</span></span>,
 into our development. The need for them
is due to the smooth combination of reasoning with <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>ositions and
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a></span>eans, which is a subject of the next chapter. Even though in
Ssreflect's library, relations on natural numbers, such as <span class="inlinecode">≤</span> and
<span class="inlinecode">&gt;</span>, are defined as <i>boolean</i> functions, so far we recommend to the
reader to think of them as of predicates defined in <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> and,
therefore, valid arguments to the <span class="inlinecode">∧</span> connective.

<div class="paragraph"> </div>

Although the statement is somewhat obvious, in the setting of Coq's
inductive definition of natural numbers it should be no big surprise
that it is proved by induction. We present the proof here, leaving the
details aside, so the reader could figure them out on her own, as a
simple exercise.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="var">suff</span> <span class="id" title="var">X</span>: <span class="id" title="var">m</span> <span class="id" title="notation">≤</span> <span class="id" title="var">n</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~(</span></a><span class="id" title="var">m</span> <span class="id" title="notation">&gt;</span> <span class="id" title="var">n</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a> <span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span>=&gt;/<span class="id" title="var">X</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">elim</span>: <span class="id" title="var">m</span> <span class="id" title="var">n</span> ⇒ [ | <span class="id" title="var">m</span> <span class="id" title="var">IHm</span> ] [ | <span class="id" title="var">n</span>] //; <span class="id" title="tactic">exact</span>: <span class="id" title="var">IHm</span> <span class="id" title="var">n</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Even this small example should make it feel like "something is not
right", as a trivial mutual exclusion property required some inductive
reasoning. A bigger problem is, however, that this mutual exclusion
does not directly provide us with a "case-analysis" principle, which a
human prover would naturally employ when reasoning about, for
instance, a natural definition of the "maximum" function

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">if</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&lt;</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">then</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">else</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

and the following fact about its correctness

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Lemma</span> <a class="idref" href="PnP.Rewriting.html#Rewriting.max_is_max"><span class="id" title="lemma">max_is_max</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>: <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> ≤ <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> ∧ <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ≤ <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The stated lemma <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.max_is_max"><span class="id" title="lemma">max_is_max</span></a></span> can be, indeed, proved by induction on
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span>, which is a rather tedious exercise, so we will not be
following this path.

<div class="paragraph"> </div>

<a name="lab42"></a><h2 class="section">Encoding custom rewriting rules</h2>



<div class="paragraph"> </div>

In the rest of this section, we will leverage the intuition behind
indexed type families considered as <i>rewriting rules</i>,
 and will try to encode a "truth table"
 with two disjoint variants of relation between
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span>, namely, <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span>. The table itself is encoded
by the following inductive definition:

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Rewriting.leq_xor_gtn"><span class="id" title="inductive">leq_xor_gtn</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <a name="Rewriting.LeqNotGtn"><span class="id" title="constructor">LeqNotGtn</span></a> <span class="id" title="keyword">of</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> : <a class="idref" href="PnP.Rewriting.html#leq_xor_gtn"><span class="id" title="inductive">leq_xor_gtn</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a name="Rewriting.GtnNotLeq"><span class="id" title="constructor">GtnNotLeq</span></a> <span class="id" title="keyword">of</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">&lt;</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a>  : <a class="idref" href="PnP.Rewriting.html#leq_xor_gtn"><span class="id" title="inductive">leq_xor_gtn</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

However, this is not yet enough to enjoy the custom rewriting and case
analysis on these two variant. At this moment, the datatype family
<span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.leq_xor_gtn"><span class="id" title="inductive">leq_xor_gtn</span></a></span>, whose constructors' indices encode a truth table's
"rows", specifies two substitutions in the case when <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span>
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span>, respectively and diagrammatically looks as follows:

<div class="paragraph"> </div>

<pre>
         |   C1  |   C2
-------------------------
m &lt;= n   | true  | false
-------------------------
n &lt; m    | false | true
</pre>

<div class="paragraph"> </div>

The boolean values in the cells specify what the values of
 and  will be substituted <i>with</i> in each of
the two cases. However, the table does not capture, what to substitute
them <i>for</i>.  Therefore, our next task is to provide suitable variants
for  and , so the table would describe a
real situation and capture exactly the "case analysis" intuition. This
values of the columns are captured by the following lemma, which,
informally speaking, states that the table with this particular values
of  and  "makes sense".

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Lemma</span> <span class="id" title="lemma">leqP</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="PnP.Rewriting.html#Rewriting.leq_xor_gtn"><span class="id" title="inductive">leq_xor_gtn</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> (<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ≤ <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> &lt; <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>).<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">ltnNge</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span> <span class="id" title="var">le_mn</span>: (<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ≤ <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>); <span class="id" title="tactic">constructor</span>=&gt;//; <span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">ltnNge</span> <span class="id" title="var">le_mn</span>.<br/>
<span class="id" title="keyword">Qed</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Moreover, the lemma <span class="inlinecode"><span class="id" title="lemma">leqP</span></span>, which we have just proved, delivers the
necessary instance of the "truth" table, which we can now case-analyse
against.In theory, a different lemma could be proven for
the same table but for different values of indices, which would give
us a <i>different</i> rewriting principle. However, the datatype family
<span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.leq_xor_gtn"><span class="id" title="inductive">leq_xor_gtn</span></a></span>, as it's currently specified, is too "tight" to admit
other instances than the one provided by the lemma <span class="inlinecode"><span class="id" title="lemma">leqP</span></span>, thanks to
the explicit constructors' arguments: <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span>.

<div class="paragraph"> </div>

<a name="lab43"></a><h2 class="section">Using custom rewriting rules</h2>


<div class="paragraph"> </div>

Let us see now, how some proofs might be changed to the good:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.huh'"><span class="id" title="lemma">huh'</span></a> <span class="id" title="var">n</span> <span class="id" title="var">m</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&gt;</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Let us first "switch" from the propositional conjunction <span class="inlinecode">∧</span> to the
boolean one <span class="inlinecode">&amp;&amp;</span> using the <i>view</i> mechanism by using the <span class="inlinecode"><span class="id" title="tactic">move</span></span>
tactics the trailing tactical . This
trick might look a bit unfair at the moment, but it will be soon
explained in 

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>/<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#andP"><span class="id" title="lemma">andP</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ≤ <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> &lt; <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The top assumption <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> of the goal is just a syntactic sugar
for <span class="inlinecode">(<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>)</span> <span class="inlinecode">&amp;&amp;</span> <span class="inlinecode">(<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>)</span>. 
It is time now to make use of our rewriting rule/truth table,
constructed by means of <span class="inlinecode"><span class="id" title="lemma">leqP</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">case</span>:<span class="id" title="lemma">leqP</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ≤ <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> &amp;&amp; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
<br/>
<span class="id" title="keyword">subgoal</span> 2 (<span class="id" title="var">ID</span> 638) <span class="id" title="keyword">is</span>:<br/>
&nbsp;<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> &lt; <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> &amp;&amp; <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We would recommend to try stepping this line several times, back and
forth to see, what is happening. Two goals were generated, so let us
focus on the first one, as the second one will proceed by
analogy. Case-analysing on the statement of the lemma <span class="inlinecode"><span class="id" title="lemma">leqP</span></span> resulted
in two different "options", as one would expect from the shape of the
table. The first, case, <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span>, resulted in generating the
assumption <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">≤</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span>, as it is an argument of the corresponding
constructor. What is more important, <i>all</i> occurrences of the columns'
values were replaced in the goal by the corresponding boolean values,
just as it was encoded in the table! The similar thing happened with
the second goal, which encoded the alternative case, i.e., <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span>.

<div class="paragraph"> </div>

Now, considering a boolean value <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span> <span class="inlinecode">&amp;&amp;</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a></span> in a goal simply as a
proposition <span class="inlinecode">(<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span> <span class="inlinecode">&amp;&amp;</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a>)</span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span>, the proof is trivial by
simplification of the boolean conjunction.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The proof of <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.huh'"><span class="id" title="lemma">huh'</span></a></span> is now indeed significantly shorter than the proof
of its predecessor, <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.huh"><span class="id" title="lemma">huh</span></a></span>. However, it might look like the definition
of the rewriting rule <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.leq_xor_gtn"><span class="id" title="inductive">leq_xor_gtn</span></a></span> and its accompanying lemma <span class="inlinecode"><span class="id" title="lemma">leqP</span></span>
is quite narrowly-scoped, and it is not clear how useful it might be
for other proofs.

<div class="paragraph"> </div>

To demonstrate the custom rewriting rules defined by means of indexed
datatype families in their shine, let us get back to the definition
of <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a></span> and the lemma about it:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.max_is_max"><span class="id" title="lemma">max_is_max</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span>: <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The proof begins by unfolding the definition of <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">
<span class="id" title="tactic">rewrite</span> /<a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> ≤ (<span class="id" title="keyword">if</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> &lt; <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>) ∧ <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ≤ (<span class="id" title="keyword">if</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> &lt; <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">then</span> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We are now in the position to unleash our rewriting rule, which,
together with simplifications by means of the <span class="inlinecode">//</span> tactical
 does most of the job.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">case</span>: <span class="id" title="lemma">leqP</span>=&gt;//.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> &lt; <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> → <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> ≤ <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> ∧ <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ≤ <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The rest of the proof employs rewriting by some trivial lemmas from
<span class="inlinecode"><span class="id" title="library">ssrnat</span></span>,  but conceptually is very easy.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>⇒<span class="id" title="var">H</span>; <span class="id" title="tactic">split</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span>: <span class="id" title="lemma">leqnn</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">ltn_neqAle</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">case</span>/<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#andP"><span class="id" title="lemma">andP</span></a>: <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The key advantage we got out of using the custom rewriting rule,
defined as an indexed datatype family is lifting the need to prove <i>by
induction</i> a statement, which one would intuitively prove by means of
<i>case analysis</i>. In fact, all inductive reasoning was conveniently
"sealed" by the proof of <span class="inlinecode"><span class="id" title="lemma">leqP</span></span> and the lemmas it made use of, so just
the tailored "truth table"-like interface for case analysis was given
to the client.

<div class="paragraph"> </div>

We invite the reader to exercise in using the custom rewriting rules
by proving a series of properties of <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a></span>.

<div class="paragraph"> </div>

 

<div class="paragraph"> </div>

Prove the following lemmas about <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.max_l"><span class="id" title="lemma">max_l</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span>: <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">≤</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.succ_max_distr"><span class="id" title="lemma">succ_max_distr</span></a> <span class="id" title="var">n</span> <span class="id" title="var">m</span> : <span class="id" title="notation">(</span><a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a><span class="id" title="notation">).+1</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> (<a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a><span class="id" title="notation">.+1</span>) (<a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a><span class="id" title="notation">.+1</span>).<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.plus_max_distr_l"><span class="id" title="lemma">plus_max_distr_l</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span> <span class="id" title="var">p</span>: <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> (<a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 It might be useful to employ the lemmas <span class="inlinecode"><span class="id" title="lemma">ltnNge</span></span>, <span class="inlinecode"><span class="id" title="lemma">leqNgt</span></span>,
 <span class="inlinecode"><span class="id" title="lemma">ltnS</span></span> and similar from Ssreflect's <span class="inlinecode"><span class="id" title="library">ssrnat</span></span> 
 module. Use the <span class="inlinecode"><span class="id" title="keyword">Search</span></span> command to find propositions that might help
 you to deal with the goal.

<div class="paragraph"> </div>

 Forward-style reasoning via <span class="inlinecode"><span class="id" title="var">suff</span></span> and <span class="inlinecode"><span class="id" title="var">have</span></span> might be more
 intuitive.

<div class="paragraph"> </div>

 A hypothesis of the shape <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a>:</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> is a syntactic sugar for
 <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a>:</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span>, since <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a></span> in fact has type <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a></span>, as will be
 explained in .

<div class="paragraph"> </div>



<div class="paragraph"> </div>

We conclude this section and the chapter by showing an instance of a
more sophisticated custom rewriting rule, which now encodes a
three-variant truth table for the ordering relations on natural
numbers.

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="Rewriting.nat_rels"><span class="id" title="inductive">nat_rels</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Set</span> :=<br/>
&nbsp;&nbsp;| <a name="Rewriting.CompareNatLt"><span class="id" title="constructor">CompareNatLt</span></a> <span class="id" title="keyword">of</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&lt;</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> : <a class="idref" href="PnP.Rewriting.html#nat_rels"><span class="id" title="inductive">nat_rels</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a name="Rewriting.CompareNatGt"><span class="id" title="constructor">CompareNatGt</span></a> <span class="id" title="keyword">of</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&gt;</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> : <a class="idref" href="PnP.Rewriting.html#nat_rels"><span class="id" title="inductive">nat_rels</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;| <a name="Rewriting.CompareNatEq"><span class="id" title="constructor">CompareNatEq</span></a> <span class="id" title="keyword">of</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> : <a class="idref" href="PnP.Rewriting.html#nat_rels"><span class="id" title="inductive">nat_rels</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Prove the following rewriting lemma for <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.nat_rels"><span class="id" title="inductive">nat_rels</span></a></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.natrelP"><span class="id" title="lemma">natrelP</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span> : <a class="idref" href="PnP.Rewriting.html#Rewriting.nat_rels"><span class="id" title="inductive">nat_rels</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> (<a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&lt;</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a>) (<a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">&lt;</span> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a>) (<a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">==</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a>).<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>



<div class="paragraph"> </div>

Let us define the minimum function <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.minn"><span class="id" title="definition">minn</span></a></span> on natural numbers as
follows:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="Rewriting.minn"><span class="id" title="definition">minn</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">if</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">&lt;</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">then</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">else</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
</div>

<div class="doc">
Prove the following lemma about <span class="inlinecode"><span class="id" title="var">minm</span></span> and <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a></span>:

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="Rewriting.addn_min_max"><span class="id" title="lemma">addn_min_max</span></a> <span class="id" title="var">m</span> <span class="id" title="var">n</span> : <a class="idref" href="PnP.Rewriting.html#Rewriting.minn"><span class="id" title="definition">minn</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#Rewriting.maxn"><span class="id" title="definition">maxn</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.Rewriting.html#m"><span class="id" title="variable">m</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.Rewriting.html#n"><span class="id" title="variable">n</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
<script src="https://jscoq.github.io/node_modules/jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
<script src="../js/jscoq-embed.js" type="text/javascript"></script>
</html>
