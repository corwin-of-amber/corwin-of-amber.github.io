<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../js/clean.css" rel="stylesheet" type="text/css" />
<title>PnP.Introduction</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library PnP.Introduction</h1>

<div class="code">
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

These lecture notes are the result of the author's personal experience
of learning how to structure formal reasoning using the Coq proof
assistant and employ Coq in large-scale research projects. The present
manuscript offers a brief and practically-oriented introduction to the
basic concepts of mechanized reasoning and interactive theorem
proving.

<div class="paragraph"> </div>

The primary audience of this text are the readers with expertise in
software development and programming and knowledge of discrete
mathematic disciplines on the level of an undergraduate university
program. The high-level goal of the course is, therefore, to
demonstrate how much the rigorous mathematical reasoning and
development of robust and intellectually manageable programs have in
common, and how understanding of common programming language concepts
provides a solid background for building mathematical abstractions and
proving theorems formally. The low-level goal of this course is to
provide an overview of the Coq proof assistant, taken in its both
incarnations: as an expressive functional programming language with
dependent types and as a proof assistant providing support for
mechanized interactive theorem proving.

<div class="paragraph"> </div>

By aiming for these two goals, this manuscript is, thus, intended to
provide a demonstration how the concepts familiar from the mainstream
programming languages and serving as parts of good programming
practices can provide illuminating insights about the nature of
reasoning in Coq's logical foundations and make it possible to reduce
the burden of mechanical theorem proving. These insights will
eventually give the reader a freedom to focus solely on the
<i>essential</i> part of her formal development instead of fighting with a
proof assistant in futile attempts to encode the "obvious"
mathematical intuition---a reason that made many of the new-comers
abandon their attempts to apply the machine-assisted approach for
formal reasoning as an everyday practice.

<div class="paragraph"> </div>

<a name="lab1"></a><h1 class="section">Why yet another course on Coq?</h1>


<div class="paragraph"> </div>

The Coq proof assistant has been in development
since 1983, and by now there is a number of courses that provide
excellent introductions into Coq-powered interactive theorem proving
and software development. Among the other publicly available
manuscripts, the author finds the following three to be the most
suitable for teaching purposes.

<div class="paragraph"> </div>

<ul class="doclist">
<li> The classical book <i>Interactive Theorem Proving and Program
  Development. Coq'Art: The Calculus of Inductive Constructions</i> by
  Yves Bertot and Pierre  is
  a great and exhaustive overview of Coq as a formal system and a
  tool, covering both logical foundations, reasoning methodologies,
  automation tools and offering large number of examples and
  exercises (from which this course borrows some).

<div class="paragraph"> </div>


</li>
<li> Benjamin Pierce et al.'s <i>Software Foundations</i> electronic book introduces Coq development from an angle of the basic research in programming languages, focusing primarily on formalization of program language semantics and type systems, which serve both as main motivating examples of Coq usage and a source of intuition for explaining Coq's logical foundations.

<div class="paragraph"> </div>


</li>
<li> The most recently published book, <i>Certified Programming with Dependent Types</i> by Adam Chlipala provides a gentle introduction to Coq from the perspective of writing programs that manipulate <i>certificates</i>, i.e., first-class proofs of the program's correctness. The idea of certified programming is a natural fit for a programming language with dependent types, which Coq offers, and the book is structured as a series of examples that make the dependently-typed aspect of Coq shine, along with the intuition behind these examples and a detailed overview of state-of-the-art <i>proof automation</i> techniques.

</li>
</ul>

<div class="paragraph"> </div>

Although all the three books have been used in numerous introductory courses for Coq with a large success, it is the author's opinion that there are still some topics essential for grasping the intuition behind rigorous and boilerplate-free mathematical reasoning via a proof assistant that are left underrepresented. This course is targeted to fill these gaps, while giving the reader enough background to proceed as a Coq hacker on her own. In particular, this manuscript describes in detail the following aspects of proof engineering, most of which are enabled or empowered by Gonthier et al.'s <i>small-scale reflection</i> extension (Ssreflect) to Coq and its accompanying library called Mathematical Components:

<div class="paragraph"> </div>



<div class="paragraph"> </div>

<ul class="doclist">
<li> Special treatment is given to the <i>computational</i> nature of inductive reasoning about <i>decidable</i> propositions, which makes it possible to compute a result of the vast majority of them (as opposed to prove them constructively) as a boolean value, given that they are formulated as computable recursive Coq functions, rather than inductive predicates (which is more in the spirit of the traditional Coq school).

<div class="paragraph"> </div>


</li>
<li> Instead of supplying the reader with a large vocabulary of tactics necessary for everyday Coq hacking, this course focuses on a <i>very small</i> but expressive set of proof constructing primitives (of about a seven in total), offered by Ssreflect or inherited from the vanilla Coq with notable enhancements.

<div class="paragraph"> </div>


</li>
<li> This course advocates inductive types' <i>parameters</i> as an alternative to <i>indices</i> as a way of reasoning about explicit equalities in datatypes with constraints.

<div class="paragraph"> </div>


</li>
<li> The reasoning by rewriting is first presented from the perspective of Coq's definition of propositional equality and followed by elaboration on the idea of using <i>datatype indices</i> as a tool to define client-specific conditional <i>rewriting rules</i>.

<div class="paragraph"> </div>


</li>
<li> This manuscript explains the essentials of Ssreflect's <i>boolean reflection</i> between the sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> and the datatype <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a></span> as a particular case of conditional rewriting, following the spirit of the computational approach to the proofs of decidable propositions.

<div class="paragraph"> </div>


</li>
<li> Formal encoding of familiar mathematical structures (e.g., monoids and lattices) is presented by means of Coq's <i>dependent records</i> and overloading mathematical operations using the mechanism of <i>canonical instances</i>.

<div class="paragraph"> </div>


</li>
<li> A novel (from a teaching perspective) case study is considered, introducing the readers to the concepts of Hoare Type Theory and describing the basics of type-based reasoning about <i>imperative programs</i> by means of <i>shallow embedding</i>.

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab2"></a><h2 class="section">What this course is about</h2>


<div class="paragraph"> </div>

Besides the enumerated above list of topics, which are described in detail and supported by a number of examples, this course supplies some amount of "standard" material required to introduce a reader with a background in programming and classical mathematical disciplines to proof engineering and program development in Coq. It starts from explaining how simple functional programs and datatypes can be defined and executed in the programming environment of Coq, proceeding to the definition of propositional logic connectives and elements of interactive proof construction. Building further on the programming intuitions about algebraic datatypes, this manuscript introduces a definition of propositional equality and the way to encode custom rewriting rules, which then culminates with a discussion on the boolean reflection and reasoning by means of computation. This discussion is continued by revising important principles of proofs by induction in Coq and providing pointers to the standard Ssreflect libraries, which should be used as a main component for everyday mathematical reasoning. The course concludes by reconciling all of the described concepts and Coq/Ssreflect reasoning principles by tackling a large case study---verifying imperative programs within the framework of Nanevski et al.'s Hoare Type Theory.

<div class="paragraph"> </div>

<a name="lab3"></a><h2 class="section">What this course is not about</h2>


<div class="paragraph"> </div>

There is a range of topics that this course does not cover, although it is the author's belief that the provided material should be sufficient for the reader to proceed to these more advanced subjects on her own. Some of the exciting topics, which are certainly worth studying but lie beyond the scope of this manuscript, are listed below together with pointers to the relevant bibliographic references.

<div class="paragraph"> </div>

<ul class="doclist">
<li> Reasoning about infinite objects in Coq via co-induction (see Chapters 5 and 7 of the book as well as the research papers).

<div class="paragraph"> </div>


</li>
<li> Proof automation by means of tactic engineering (see and the papers) or lemma overloading.

<div class="paragraph"> </div>


</li>
<li> Using a proof assistant in the verification of program calculi and optimizing compilers as well as employing Coq to specify and verify low-level and concurrent programs.

</li>
</ul>

<div class="paragraph"> </div>

<a name="lab4"></a><h2 class="section">Why Ssreflect?</h2>


<div class="paragraph"> </div>



<div class="paragraph"> </div>

A significant part of this course's material is presented using the Ssreflect extension of Coq and its accompanying libraries, developed as a part of the Mathematical Components project in order to facilitate the automated reasoning in very large mathematical developments, in particular, the fully formal machine-checked proofs of the  and .

<div class="paragraph"> </div>

  

<div class="paragraph"> </div>

Ssreflect includes a small set of powerful novel primitives for interactive proof construction (tactics), different from the traditional set provided by Coq. It also comes with a large library of various algebraic structures, ranging from natural numbers to graphs, finite sets and algebras, formalized and shipped with exhaustive toolkits of lemmas and facts about them. Finally, Ssreflect introduces some mild modifications to Coq's native syntax and the semantics of the proof script interpreter, which makes the produced proofs significantly more concise.

<div class="paragraph"> </div>

Using Ssreflect for the current development is not the goal by itself: a large part of the manuscript could be presented using traditional Coq without any loss in the insights but, perhaps, some loss in brevity. However, what is more important, using Ssreflect's libraries and tactics makes it much easier to stress the main points of this course, namely, that (a) the proof construction process should rely on Coq's native computational machinery as much as possible and (b) rewriting (in particular, by equality) is one of the most important proof techniques, which should be mastered and leveraged in the proofs. Luckily, the way most of the lemmas in Ssreflect and Mathematical Components libraries are implemented makes them immediately suitable to use for rewritings, which directly follows the natural mathematical intuition. The enhancements Ssreflect brings over the standard Coq rewriting machinery also come in handy.

<div class="paragraph"> </div>

Last, but not least, Ssreflect comes with a much improved <span class="inlinecode"><span class="id" title="keyword">Search</span></span> tool (comparing to the standard one of Coq). Given that a fair part of time spent for development (either programs and proofs) is typically dedicated to reading and understanding the code (or, at least, specifications) written by other implementors, the <span class="inlinecode"><span class="id" title="keyword">Search</span></span> tool turns out to be invaluable when it comes to looking for necessary third-party facts to employ in one's own implementation.

<div class="paragraph"> </div>

In the further chapters of this course, we will not be making distinction between native Coq and Ssreflect-introduced commands, tactics and tacticals, and will keep the combined lists of them in the Index section at the end of the manuscript.

<div class="paragraph"> </div>

<a name="lab5"></a><h1 class="section">Prerequisites</h1>


<div class="paragraph"> </div>

The reader is expected to have some experience with mainstream object-oriented and functional programming languages, such as Scala, Haskell, OCaml or Standard ML. While strong knowledge of any of the mentioned languages is not mandatory, it might be useful, as many of the Coq's concepts making appearance in the course are explained using the analogies with constructs adopted in practical programming, such as algebraic datatypes, higher-order functions, records and monads.

<div class="paragraph"> </div>

While this manuscript is aiming to be self-contained in its presentation of a subset of Coq, it would be to expect it to be the <i>only</i> Coq reference used for setting-up a formal development. That said, we encourage the reader to use the standard Coq manual as well as Ssreflect documentation whenever an unknown tactic, piece of syntax or obscure notation is encountered. Coq's <span class="inlinecode"><span class="id" title="keyword">Search</span></span>,  and <span class="inlinecode"><span class="id" title="keyword">Print</span></span> tools, explained in  are usually of great help when it comes to investigating what someone's Coq code does, so don't hesitate to use them.

<div class="paragraph"> </div>

Finally, we assume that the Emacs text editor  with a Proof General mode installed  (as explained further in this chapter) will be used as the environment for writing code scripts, and the GNU  machinery is available on the reader's machine in order to build the necessary libraries and tools.

<div class="paragraph"> </div>

<a name="lab6"></a><h1 class="section">Setup</h1>


<div class="paragraph"> </div>

In order to be able to follow the manuscript and execute the examples provided, the reader is expected to have Coq with Ssreflect installed on her machine. This section contains some general instructions on the installation and set-up. Most of the mentioned below sources can be downloaded from the following URL, accompanying these notes:

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Alternatively, you can clone the sources of these lecture notes, along with the exercises and the solution from the following public GitHub repository:

<div class="paragraph"> </div>



<div class="paragraph"> </div>

<a name="lab7"></a><h2 class="section">Installing Coq, Ssreflect and Mathematical Components</h2>


<div class="paragraph"> </div>

The sources of this manuscript have been compiled and tested with Coq version 8.9.0, Ssreflect/Mathematical Components version 1.8.0, and FCSL PCM version 1.1.0. It is not guaranteed that the same examples will work seamlessly with different versions. Therefore, several recipes on how to build and install the necessary software are provided below.

<div class="paragraph"> </div>

The easiest way to obtain the necessary versions of Coq and the libraries is
to install them via the OPAM package manager ():

<div class="paragraph"> </div>

<pre>
opam install coq.8.9.0
</pre>

<div class="paragraph"> </div>

In order to install Ssreflect/Mathematical Components and FCSL PCM,
you will need to register the corresponding
repository and then install the packages as follows:

<div class="paragraph"> </div>

<pre>
opam repo add coq-released https://coq.inria.fr/opam/released 
opam install coq-mathcomp-ssreflect.1.8.0 coq-fcsl-pcm.1.1.0
</pre>

<div class="paragraph"> </div>

Alternatively, you can compile Coq 8.9.0, Ssreflect/Mathematical
Components version 1.8.0, and
FCSL PCM 1.1.0
from sources.
In order to be compiled, Coq requires OCaml version 4.02.3 or later, Camlp5 version 6.13 or later, GNU Make version 3.81 or later (see the <tt>INSTALL</tt> file from the archive with sources for more details on configuration and installation). Once compiled and installed, the following environment variables should be set (e.g., in <tt>~/.bashrc</tt> or <tt>~/.profile</tt> configuration files) to build the libraries (with the respective paths chosen during the Coq's installation):

<div class="paragraph"> </div>

<pre>
export COQBIN="/usr/local/bin/" 
export COQ_MK="/usr/local/bin/coq_makefile" 
</pre>

<div class="paragraph"> </div>

After installation, it is recommended to keep the sources of Ssreflect/Mathematical Components and FCSL PCM easily accessible as reading them might be helpful when working with the libraries (for instance, put them into the folders <tt>~/misc/math-comp-1.8.0</tt> and <tt>~/misc/fcsl-pcm-1.1.0</tt>).

<div class="paragraph"> </div>

<a name="lab8"></a><h2 class="section">Emacs set-up</h2>


<div class="paragraph"> </div>

The Emacs (or Aquamacs for macOS users) text editor provides a convenient environment for Coq development, thanks to the Proof General mode. After downloading and installing Emacs, clone the Git repository of Proof General, and Ssreflect/Mathematical Components following the instructions below.
Upon cloning both repositories, for instance, into the folders <tt>~/misc/PG/</tt> and <tt>~/misc/math-comp-1.8.0/</tt>, add the following lines into the  configuration file located in the home directory in Unix and in the <tt>C:\</tt> root in Windows (possibly replacing the  part with the path where the Proof General and Ssreflect/Mathematical Components repositories were).

<div class="paragraph"> </div>

<pre>
;; Proof General support 
(load-file "~/misc/PG/generic/proof-site.el")

;; Ssreflect support 
(load-file "~/misc/math-comp-1.8.0/mathcomp/ssreflect/pg-ssr.el")
</pre>

<div class="paragraph"> </div>

Linux users who are more used to the Windows-style Copy/Paste/Undo keystrokes can also find it convenient to enable the Cua mode in Emacs, which can be done by adding the following lines into the  file:

<div class="paragraph"> </div>

<pre>
(cua-mode t) 
(setq cua-auto-tabify-rectangles nil) 
(transient-mark-mode 1) 
(setq cua-keep-region-after-copy t) 
</pre>

<div class="paragraph"> </div>

Every Coq file has the extension . Opening any  file will automatically trigger the Proof General mode.

<div class="paragraph"> </div>

Finally, the optional Company-Coq collection of extensions to Proof General adds many modern IDE features such as auto-completion of tactics and names, refactoring, and inline help.

<div class="paragraph"> </div>

<a name="lab9"></a><h2 class="section">Getting the lecture files and solutions</h2>



<div class="paragraph"> </div>

The reader is encouraged to download the additional material for this course in the form of Coq files with all examples from the manuscript plus some additional exercises. The sources can be obtained from the .
The Coq files accompanying lectures (with solutions omitted) are contained in the  folder.
For the examples of Chapter and the corresponding lecture source file, the sources of the Hoare Type Theory (HTT) development will be required. 
The current version of the notes includes the ready-to-use up-to-date sources of HTT in the folder .
Solutions for all of the exercises can be found in the folder  of the GitHub project accessible by the link above.

<div class="paragraph"> </div>

After the sources are cloned, run <tt>make</tt> from the root folder. This will build all necessary libraries, lectures, solutions for the exercises, and the lecture notes. The resulting PDF file is .

<div class="paragraph"> </div>

The table below describes the correspondence between the chapters of the manuscript and the accompanying files.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

<a name="lab10"></a><h1 class="section">Naming conventions</h1>


<div class="paragraph"> </div>

Coq as a tool and environment for interactive theorem proving
incorporates a number of entities in itself. As a programming and
specification language, Coq implements a dependently-typed <i>calculus</i>
(i.e., a small formal programming language) <i>Gallina</i>,
 which is an extension of the <i>Calculus of Inductive
Constructions</i> (CIC) explained in Chapter. Therefore,
all the expressions and programs in Coq, including standard
connectives (e.g.,  or ) are
usually referred to as <i>Gallina terms</i>. In the listing, keywords of
Gallina terms will be usually spelled using . The defined entities, such as functions, datatypes
theorems and local variables will be usually spelled in the
 or  fonts.

<div class="paragraph"> </div>

On top of the language of programs in Coq there is a language of
<i>commands</i> and <i>tactics</i>, which help to manage the proof scripts,
define functions and datatypes, and perform queries, such as searching
and printing. The language of Coq commands, such as <span class="inlinecode"><span class="id" title="keyword">Search</span></span> and
<span class="inlinecode"><span class="id" title="keyword">Print</span></span>, is called <i>Vernacular</i>.  Commands and
tactics, similarly to the keywords, are spelled in .

<div class="paragraph"> </div>

In the rest of the manuscript, though, we will be abusing the
terminology and blur the distinction between entities that belong to
Gallina, Vernacular or Coq as a framework, and will be referring to
them simply as "Coq terms", "Coq tactics" and "Coq commands".

<div class="paragraph"> </div>

In the program displays, interleaving with the text, some mathematical
symbols, such as ,  and , will be
displayed in Unicode, whereas in the actual program code they are
still spelled in ASCII, e.g., , <span class="inlinecode"><span class="id" title="tactic">∃</span></span> and
, correspondingly.

<div class="paragraph"> </div>

<a name="lab11"></a><h1 class="section">Acknowledgements</h1>


<div class="paragraph"> </div>

This course was inspired by the fantastic experience of working with
Aleks Nanevski on verification of imperative and concurrent programs
during the author's stay at IMDEA Software Institute.  Aleks'
inimitable sense of beauty when it comes to formal proofs has been one
of the main principles guiding the design of these lecture notes.

<div class="paragraph"> </div>

I'm grateful to Michael D. Adams, Amal Ahmed, Jim Apple, Daniil
Berezun, Giovanni Bernardi, Dmitri Boulytchev, William J. Bowman,
Kirill Bryantsev, Santiago Cuellar, Andrea Cerone, Olivier Danvy,
,  Francisco Morales, Phillip Mates,
Gleb Mazovetskiy, Anton V. Nikishaev, Karl Palmskog, Daniel Patterson, Anton Podkopaev, 
Leonid Shalupov, Kartik Singhal, Jan Stolarek, Anton Trunov and James R. Wilcox who provided a lot 
of valuable feedback and found countless typos in earlier versions of the notes.

<div class="paragraph"> </div>

The mascot picture  on the front page
is created by Lilia Anisimova.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
<script src="https://jscoq.github.io/node_modules/jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
<script src="../js/jscoq-embed.js" type="text/javascript"></script>
</html>
