<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../js/clean.css" rel="stylesheet" type="text/css" />
<title>PnP.HTT</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library PnP.HTT</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

In this chapter, we will consider a fairly large case study that makes
use of most of Coq's features as a programming language with dependent
types and as a framework to build proofs and reason about mathematical
theories.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Programming language practitioners usually elaborate on the dichotomy
between <i>declarative</i> and <i>imperative</i> languages, emphasizing the fact
that a program written in a declarative language is pretty much
documenting itself, as it already specifies the <i>result</i> of a
computation. Therefore, logic and constraint programming languages
(such as Prolog  or
Ciao) as well as data
definition/manipulation languages (e.g., SQL), whose programs are just
sets of constraints/logical clauses or queries describing the desired
result, are naturally considered to be declarative. Very often, pure
functional programming languages (e.g., Haskell) are considered as
declarative as well. The reason for this is the <i>referential
transparency</i> property, which ensures that programs in such languages
 are in fact effect-free
expressions, evaluating to some result (similar to mathematical
functions) or diverging. Therefore, such programs, whose outcome is
only a value, but not some side effect (e.g., output to a file), can
be replaced safely by their result, if it is computable. This
possibility provides a convenient way of reasoning algebraically about
such programs by means of equality rewritings---precisely what we were
observing and leveraging in  of this course in the context of Coq taken as a
functional programming language.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

That said, pure functional programs tend to be considered to be good
specifications for themselves. Of course, the term "specification" (or
simply, "spec")  is overloaded and in
some context it might mean the result of the program, its effect or
some of the program's algebraic properties. While a functional program
is already a good description of its result (due to referential
transparency), its algebraic properties (e.g., some equalities that
hold over it) are usually a subject of separate statements, which
should be proved. Good examples of such properties
are the commutativity and cancellation properties, which we proved for
natural numbers with addition, considered as an instance of PCM on
page. Another
classical series of examples, which we did not focus on in this course,
are properties of list functions, such as appending and reversal
(e.g., that the list reversal is an inverse to itself).

<div class="paragraph"> </div>

The situation is different when it comes to imperative programs, whose
outcome is typically their side-effect and is achieved by means of
manipulating mutable state, throwing an exception or performing
input/output. While some of the modern programming languages (e.g.,
Scala, OCaml) allow one to mix imperative and declarative programming
styles, it is significantly harder to <i>reason</i> about such programs, as
now they cannot be simply replaced by their results: one should also
take into account the effect of their execution (i.e., changes in the
mutable state). A very distinct approach to incorporating both
imperative and declarative programming is taken by Haskell, in which
effectful programs can always be distinguished from pure ones by means
of enforcing the former ones to have very specific
types---the idea we will elaborate
more on a bit further.

<div class="paragraph"> </div>

In the following sections of this chapter, we will learn how Coq can
be used to give specifications to imperative programs, written in a
domain-specific language, similar to C, but in fact being a subset of
Coq itself. Moreover, we will observe how the familiar proof
construction machinery can be used to establish the correctness of
these specifications, therefore, providing a way to <i>verify</i> a program
by means of checking, whether it satisfies a given spec. In
particular, we will learn how the effects of state-manipulating
programs can be specified via dependent types, and the specifications
of separate effectful programs can be <i>composed</i>, therefore allowing
us to structure the reasoning in a modular way, similarly to
mathematics, where one needs to prove a theorem only once and then can
just rely on its statement, so it can be employed in the proofs of
other facts.

<div class="paragraph"> </div>

<a name="lab72"></a><h1 class="section">Imperative programs and their specifications </h1>


<div class="paragraph"> </div>

The first attempts to specify the behaviour of state-manipulating
imperative programs with assignments originated in late '60s and are
due to Tony Hoare and Robert Floyd, who
considered programs in a simple imperative language with mutable
variables (but without pointers or procedures) and suggested to give a
specification to a program  in the form of a triple
, where  and  are logical propositions,
describing the values of the mutable variables and possible relations
between them.  and  are usually  referred to
as <i>assertions</i>; more specifically,  is called
 <i>precondition</i> of  (or
just "pre"), whereas  is called <i>postcondition</i> (or simply
"post"). The triple  is traditionally referred to
as <i>Hoare triple</i>. Its
intuitive semantics can be expressed as follows: 
"if right before the program  is executed the state of mutable
variables is described by the proposition , then, <i>if 
terminates</i>, the resulting state satisfies the proposition ".

<div class="paragraph"> </div>

 


<div class="paragraph"> </div>

The reservation on termination of the program  is important. In
fact, while the Hoare triples in their simple form make sense only for
terminating programs, it is possible to specify non-terminating
programs as well. This is due to the fact that the semantics of a
Hoare triple implies that a non-terminating program can be given <i>any</i>
postcondition, as one won't be able to check it anyway, because the
program will never reach the final state. Such
interpretation of a Hoare triple "modulo termination" is referred to
as <i>partial correctness</i>, and in this chapter we will focus on it. It
is possible to give to a Hoare triple  a
different interpretation, which would deliver a stronger property: "if
right before the program  is executed the state of mutable
variables is described by a proposition , <i>then  terminates</i> and
the resulting state satisfies the proposition ". Such property is
called <i>total correctness</i> and requires tracking some sort of "fuel"
for the program in the assertions, so it could run further. We do not
consider total correctness in this course and instead refer the reader
to the relevant research results on Hoare-style specifications with
resource bounds.

<div class="paragraph"> </div>

<a name="lab73"></a><h2 class="section">Specifying and verifying programs in a Hoare logic</h2>



<div class="paragraph"> </div>

The original Hoare logic worked over a very simplistic imperative
language with loops, conditional operators and assignments. This is
how one can specify a program, which just assigns 3 to a specific
variable named: 

<div class="paragraph"> </div>



<div class="paragraph"> </div>

That is, the program's precondition doesn't make any specific
assumptions, which is expressed by the proposition ; the
postcondition ensures that the value of a mutable variable
 is equal to three.

<div class="paragraph"> </div>

The formalism, which allows us to validate particular Hoare triples
for specific programs is called <i>program logic</i> (or, equivalently,
<i>Hoare logic</i>). 

<div class="paragraph"> </div>




<div class="paragraph"> </div>

Intuitively, logic in general is a formal system, which consists of
axioms (propositions, whose inhabitance is postulated) and <i>inference
rules</i>,  which allow one to construct proofs
of larger propositions out of proofs of small ones. This is very much
of the spirit of , where we were focusing on a
particular formalism---propositional logic. Its <i>inference rules</i> were
encoded by means of Coq's <i>datatype constructors</i>. For instance, in
order to construct a proof of conjunction (i.e., inhabit a proposition
of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>), one should have provided a proof of a proposition
<span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> and a proposition <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> and then <i>apply</i> the only conjunction's
constructor <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a></span>, as described in . The
logicians, however, prefer to write inference rules as "something with
a bar", rather than as constructors. Therefore, an inference rule for
conjunction introduction in the constructive logic looks as follows:

<div class="paragraph"> </div>



<div class="paragraph"> </div>



<div class="paragraph"> </div>

That is, the rule  is just a paraphrase of the
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a></span> constructor, which specifies how an instance of conjunction can
be created. Similarly, the disjunction <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#or"><span class="id" title="inductive">or</span></a></span> has two inference rules,
for each of its constructors. The elimination rules are converses of
the introduction rules and formalize the intuition behind the case
analysis. An alternative example of an inference rule for a
proposition encoded by means of Coq's datatype constructor is the
definition of the predicate for beautiful numbers <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.beautiful"><span class="id" title="inductive">beautiful</span></a></span> from
. There, the constructor <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.b_sum"><span class="id" title="constructor">b_sum</span></a></span> serves as
an inference rule that, given the proofs that <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a></span> is beautiful and
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#m'"><span class="id" title="variable">m'</span></a></span> is beautiful, constructs the proof of the fact that their sum is
beautiful.

<div class="paragraph"> </div>

Hoare logic also suggests a number of axioms and inference rules that
specify which Hoare triple can in fact be inferred. We postpone the
description of their encoding by means of Coq's datatypes till
 of this chapter and so far demonstrate
some of them in the logical notation "with a bar". For example, the
Hoare triple for a variable assignment is formed by the following
rule:

<div class="paragraph"> </div>



<div class="paragraph"> </div>

The rule  is in fact an axiom (since it does not assume
anything, i.e., does not take any arguments), which states that if a
proposition  is valid after substituting all occurrences of  in
it with  (which is denoted by ), then it is a valid
postcondition for the assignment .

<div class="paragraph"> </div>

The inference rule for sequential composition is actually a
constructor, which takes the proofs of Hoare triples for  and
 and then delivers a composed program  <i>as well as</i> the
proof for the corresponding Hoare triple, ensuring that the
postcondition of  matches the precondition of .


<div class="paragraph"> </div>



<div class="paragraph"> </div>

The rule  is in fact too "tight", as it requires the two
composed program agree exactly on their post-/preconditions. In order
to relax this restriction, on can use the <i>rule of consequence</i>, which
 makes it possible to <i>strengthen</i> the
precondition and <i>weaken</i> the postcondition of a program. Intuitively,
such rule is adequate, since the program that is fine to be run in a
precondition , can be equivalently run in a stronger precondition
 (i.e., the one that implies ). Conversely, if the program
terminates in a postcondition , it would not hurt to weaken this
postcondition to , such that  implies .

<div class="paragraph"> </div>



<div class="paragraph"> </div>

With this respect, we can make the analogy between Hoare triples and
function types of the form <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>, such that the rule of consequence
of a Hoare triple corresponds to subtyping of function types, where
the precondition <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is analogous to an argument type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> and the
postcondition <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> is analogous to a result type <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>. Similarly to the
functions with subtyping, Hoare triples are covariant with respect to
consequence in their postcondition and <i>contravariant</i> in the
precondition.
 This is the reason why,
when establishing a specification, one should strive to infer the
<i>weakest precondition and the strongest postcondition</i> to get the
tightest possible (i.e., the most precise) spec, which can be later
weakened using the  rule.

<div class="paragraph"> </div>

The observed similarity between functions and commands in a Hoare
logic should serve as an indicator that, perhaps, it would be a good
idea to implement the Hoare logic in a form of a type system. Getting
a bit ahead of ourselves, this is exactly what is going to happen soon
in this chapter (as the title of the chapter suggests).

<div class="paragraph"> </div>

At this point, we can already see a simple paper-and-pencil proof of a
program that manipulates mutable variables. In the Hoare logic
tradition, since most of the programs are typically compositions of
small programs, the proofs of specifications are written to follow the
structure of the program, so the first assertion corresponds to the
overall precondition, the last one is the overall postcondition, and
the intermediate assertions correspond to  from the rule
 modulo weakening via the rule of consequence
. Let us prove the following Hoare-style specification
for a program that swaps the values of two variables  and .

<div class="paragraph"> </div>



<div class="paragraph"> </div>

The variables <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a></span> are called <i>logical</i> and are used in order
to name  unspecified values, which are a
subject of manipulation in the program, and their identity should be
preserved. The logical variables are implicitly universally quantified
over in the scope of the <i>whole</i> Hoare triple they appear, but usually
the quantifiers are omitted, so, in fact, the specification above
should have been read as follows.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

This universal quantification should give some hints that converting
Hoare triples into types will, presumably, require to make some use of
dependent types in order to express value-polymorphism, similarly to
how the universal quantification has been previously used in Coq. Let
us see a proof sketch of the above stated specification with
explanations of the rules applied after each assertion.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

The list of program constructs and inference rules for them would be incomplete without conditional operators and loops.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

The inference rule for a conditional statement should be intuitively
clear and reminds of a typing rule for conditional expressions in
Haskell or OCaml, which requires both branches of the statement to
have the same type (and here, equivalently, to satisfy the same
postcondition). The rule  for the loops is more
interesting, as it makes use of the 
proposition , which is called <i>loop invariant</i>. Whenever the body
of the cycle is entered, the invariant should hold (as well as the
condition , since the iteration has just started). Upon finishing,
the body  should restore the invariant, so the next iteration would
start in a consistent state again. Generally, it takes a human
prover's intuition to come up with a non-trivial resource invariant
for a loop, so it can be used in the rest of the program. Inference of
the best loop invariant is an undecidable problem in general and it
has a deep relation to type inference with polymorphically-recursive
functions. This should not be very
surprising, since every loop can be encoded as a recursive function,
and, since, as we have already started guessing, Hoare triples are
reminiscent of types, automatic inferring of loop invariants would
correspond to type inference for recursive functions. In the
subsequent sections we will see examples of looping/recursive programs
with loop invariants and exercise in establishing some of them.

<div class="paragraph"> </div>

<a name="lab74"></a><h2 class="section">Adequacy of a Hoare logic</h2>


<div class="paragraph"> </div>

The original Hoare logic is often referred to as <i>axiomatic semantics</i>
of imperative programs. This term is only partially accurate, as it
implies that the Hoare triples describe precisely what is the program
and how it behaves. Even though Hoare logic can be seen as a program
semantics as a way to describe the program's behaviour, it is usually
not the only semantics, which imperative programs are given. In
particular, it does not say how a program should be executed---a
question answered by operational
semantics. Rather, Hoare logic allows
one to make statements about the effect the program takes to the
mutable state, and, what is more important, construct finite proofs of
these statements. With this respect, Hoare logic serves the same
purpose as type systems in many programming languages---determine
statically (i.e., without <i>executing</i> the program), whether the
program is well-behaved or not. In other words, it serves as an
"approximation" of another, more low-level semantics of a program.
This intuition is also implied by the very definition of a hoare
triple on page, which relies to the fact that a
program can be executed.

<div class="paragraph"> </div>

That said, in order to use a Hoare logic for specifying and verifying
a program's behaviour, a <i>soundness</i> result should be first
 established. In the case of a program
logic, soundness means the logic rules allow one to infer only those
statements that do not contradict the definition of a Hoare triple
(page). This result can be proven in many
different ways, and the nature of the proof usually depends on the
underlying operational/denotational semantics, which is typically not
questioned, being self-obvious, and defines precisely what does it
mean for a program <i>to be executed</i>. Traditional ways of proving
soundness of a program logic are reminiscent to the approaches for
establishing soundness of type
systems. Of course, all
program logics discussed in this chapter have been proven to be sound
with respect to some reasonable operational/denotational semantics.

<div class="paragraph"> </div>

<a name="lab75"></a><h1 class="section">Basics of Separation Logic</h1>


The original Hoare logic has many limitations. It works only with
mutable variables and does not admit procedures or first-order
code. But its most severe shortcoming becomes evident when it
comes to specifying programs that manipulate <i>pointers</i>, i.e.,
the most interesting imperative cases of imperative
code.  In the presence of pointers and a heap,
mutable variables become somewhat redundant, so for now by <i>local
variables</i> we will be assuming immutable, once-assigned variables,
akin to those bound by the -expression. Such variables
can, of course, have pointers as their values.
Let us first enrich the imperative programming language of interest to
account for the presence of heap and pointers. We will be using the
syntax  to denote the assignment of a value
 to the pointer bound by . Similarly, the
syntax  stands for dereferencing a pointer, whose address
is a value obtained by evaluating a <i>pure</i> expression . We
will assume that every program returns a value as a result (and the
result of a pointer assignment is of type <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span>). To account for
this, we will be using the syntax  (pronounced
"bind") as a generalization of the sequential composition from
. The bind first executes the program
, then <i>binds</i> this  result to an
immutable variable  and proceeds to the execution of the
program , which can possibly make use of the variable
, so all the occurrences of  in it are
replaced by its value before it starts evaluating. If the result of
 is not used by , we will use the
abbreviation  to denote this specific case.
Specifications in the simple Hoare logic demonstrated in
 are stated over mutable local
variables, which are implicitly supposed to be all distinct, as they
have distinct "abstract" names. In a language with a heap and
pointers, the state is no longer a set of mutable variables, but the
heap itself, which  can be thought of as a partial map
from natural numbers to arbitrary values. In a program, operating with
a heap, two pointer variables,  and  can in fact be <i>aliases</i>,
 i.e., refer to the same memory entry, and,
therefore, changing a value of a pointer, referenced by  will
affect the value, pointed to by . Aliasing is an aspect that
renders reasoning in the standard Hoare logic tedious and
unbearable. To illustrate the problem, let us consider the following
program, which runs in the assumption that the heap, which is being
available to the program, has only two entries with addresses,
referred to by local variables  and  correspondingly, so the
specification states it by means of the "points-to" assertions , where  is assumed to be a pointer value.


The logical variable  is of importance, as it is used to state that
the value of the pointer  remains unchanged after the program has
terminated. Alas,
this specification is not correct, as the conjunction of the two does
not distinguish between the case when  and  are the same pointer
and when they are not, which is precisely the aliasing problem. It is
not difficult to fix the specification for this particular example by
adding a conditional statement (or, equivalently, a disjunction) into
the postcondition that would describe two different outcomes of the
execution with respect to the value of , depending on the fact
whether  and  are aliases or not. However, if a program
manipulates with a large number of pointers, or, even worse, with an
array (which is obviously just a sequential batch of pointers), things
will soon go wild, and the conditionals with respect to equality or
non-equality of certain pointers will pollute all the specifications,
rendering them unreadable and eventually useless. This was precisely
the reason, why after being discovered in late '60s and investigated
for a decade, Hoare-style logics were soon almost dismissed as a
specification and verification method, due to the immense complexity
of the reasoning process and overwhelming proof obligations.
 
The situation has changed when in 2002 John C. Reynolds, Peter
O'Hearn, Samin Ishtiaq and Hongseok Yang suggested an alternative way
to state Hoare-style assertions about heap-manipulating programs with
pointers. The key idea was to make <i>explicit</i>
the fact of disjointness (or, <i>separation</i>) between different parts of
a heap in the pre- and postconditions. This insight made it possible
to reason about disjointness of heaps and absence of aliasing without
the need to emit side conditions about equality of pointers. The
resulting formal system received the name <i>separation logic</i>, and
below we consider a number of examples to specify and verify programs
in it.
For instance, the program, shown above, which assigns  to a pointer
 can now be given the following specification in the separation
logic:

We emphasize the fact that the heaps, being just partial maps from
natural numbers to arbitrary values, are elements of a PCM
 with the operation  taken to be a
disjoint union and the unit element to be an empty heap (denoted
).  The above assertions therefore ensure that,
before the program starts, it operates in a heap , such that  is
a partial map, consisting of two <i>different</i> pointers,  and ,
such that  points to some universally-quantified value , and the
content of  is of no importance (which is denoted by <span class="inlinecode">-</span>). The
postcondition makes it explicit that only the value of the pointer 
has changed, and the value of  remained the same. The
postcondition also mentions the result  of the whole operations,
which is, however, not constrained anyhow, since, as it has been
stated, it is just a value of type <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span>.
<a name="lab76"></a><h2 class="section">Selected rules of Separation Logic</h2>


Let us now revise some of the rules of Hoare logic and see how they
will look in separation logic. The rules, stated over the heap, are
typically given in the <i>small footprint</i>, 
meaning that they are stated with the smallest possible heap and assume
that the "rest" of the heap, which is unaffected by the program
specified, can be safely assumed. The rules for assigning and reading
the pointers are natural.

Notice, though, that, unlike the original Hoare logic for mutable
variables, the rule for writing explicitly requires the pointer  to
be present in the heap. In other words, the corresponding memory cell
should be already <i>allocated</i>. This is why the traditional separation
logic assumes presence of an allocator, which can allocate new memory
cells and dispose them via the effectful functions 
and , correspondingly.

For the sake of demonstration, the rules for  and
 are given in a <i>large footprint</i> that, in contrast
with  small footprint-like specifications,
mentions the "additional" heap  in the pre- and post-conditions,
which can be arbitrarily instantiated, emphasizing that it remains
unchanged (recall that  is implicitly universally-quantified over,
and its scope is the whole triple), so the resulting heap is just being
"increased"/"decreased" by a memory entry that has been
allocated/deallocated.
The rule for binding is similar to the rule for sequential composition
of programs  and  from the standard Hoare logic, although it
specifies that the immutable variables can be substituted in .

The predicates ,  and  in the rule  are
considered to be functions of the heap and result,
correspondingly. This is why for the second program, , the
predicate  in a precondition is instantiated with , which can
occur as a free variable in . The rule of weakening
 is similar to the one from Hoare logic modulo the
technical details on how to weaken heap/result parametrized functions,
so we omit it here as an intuitive one. The rule for conditional
operator is the same one as in , and,
hence, is omitted as well.
In order to support procedures in separation logic, we need to
consider two additional rules---for function invocation and returning
a value.


The rule for returning simply constraints the dedicated variable
 to be equal to the expression . The rule  (for
"hypothesis") introduces the assumption context  that contains
specifications of available "library" functions (bearing the
reminiscence with the typing context in typing
relations) and until now was assumed
to be empty. Notice that, similarly to dependently-typed functions, in
the rule  the pre- and postcondition in the spec of the
assumed function can depend on the value of its argument . The rule
 accounts for the function application and instantiates
all occurrences of  with the argument expression .
Finally, sometimes we might be able to infer two different
specifications about the same program. In this case we should be able
to combine them into one, which is stronger, and this is what the
rule of conjunction  serves for:

<a name="lab77"></a><h2 class="section">Representing loops as recursive functions</h2>


It is well-known in a programming language folklore that every
imperative loop can be rewritten as a function, which is
tail-recursive, i.e., it performs the call of itself only as the very
last statement in some possible execution branches and doesn't call
itself at all in all other branches. Therefore, recursive functions in
general  are a more expressive mechanism, as
they also allow one to write non-tail recursive programs, in which
recursive calls occur in any position. Therefore, an
imperative program of the form
 
 can be rewritten using a recursive function, defined via
the in-place fixpoint operator as
 
That is, the function  is defined with an argument of the
bool type and is immediately invoked. If the condition argument
 is satisfied, the body  is executed and the
function calls itself recursively with a new argument ;
otherwise the function just returns a unit result. For the first time,
the function is invoked with some initial argument .
Given this relation between imperative loops and effectful recursive
functions, we won't be providing a rule for loops in separation logic
at all, and rather provide one for recursive definitions.

The premise of the rule  already <i>assumes</i> the
specification of a function  (i.e., its <i>loop invariant</i>)
 in the context  and requires one to
verify its body  for the same specification, similarly to how
recursive functions in some programming languages (e.g.,
Scala) require explicit type annotations
to be type-checked.
In the remainder of this chapter we will be always implementing
imperative loops via effectful recursive functions, whose
specifications are stated explicitly, so the rule above would be
directly applicable.
<a name="lab78"></a><h2 class="section">Verifying heap-manipulating programs</h2>


Let us now see how a simple imperative program with conditionals and
recursion would be verified in a version of separation logic that we
presented here. A subject of our experiment will be an efficient
imperative implementation of a factorial-computing function, which
<i>accumulates</i> the factorial value in a specific variable, while
decreasing its argument in a loop, and returns the value of the
accumulator when the iteration variable becomes zero. In the
pseudocode, the  program is implemented as follows:

The function  first allocates two pointers,
 and  for the iteration variable and the
accumulator, correspondingly. It will then initiate the loop,
implemented by the recursive function , that reads the
values of  and  into local immutable
variables  and , correspondingly and then
checks whether  is zero, in which case it returns the
value of the accumulator. Otherwise it stores into the accumulator the
old value multiplied by , decrements  and
re-iterates. After the loop terminates, the two pointers are
deallocated and the main function returns the result.
Our goal for the rest of this section will be to verify this program
semi-formally, using the rules for separation logic presented above,
against its <i>functional</i> specification. In other words, we will have
to check that the program  returns precisely the
factorial of its argument value . To give such specification to
, we define two auxiliary mathematical functions, 
and :

It is not difficult to see that  defines exactly the factorial
function as one would define it in a pure functional language (not
very efficiently, though, but in the most declarative form). The
second function  is in fact a predicate, which we will use to
give the loop invariant to the loop function . Now, the
function  can be given the following specification in
separation logic, stating that it does not <i>leak</i> memory and its
result is the factorial of its argument .

In the course of the proof of the above stated spec of ,
in order to apply the rule , we pose the specification of
 (in an implicit assumption context  from the
rules) to be the following one. The specification states that the body
of the loop preserves the invariant , and, moreover its result
is the factorial of .

Below, we demonstrate a proof sketch of verification of the body of
 against its specification by systematically applying all
of the presented logic rules.

Probably, the most tricky parts of the proof, which indeed require a
human prover's insight, are (a) "decomposition" of the loop invariant
 at the beginning of the loop, when it falls into the
components, constraining the values of  and  in
the heap and (b) the "re-composition" of the same invariant
immediately before the recursive call of  in order to
ensure its precondition. The latter is possible because of algebraic
properties of the factorial function , namely the fact that for any
, if  then , the
insight we have used in order to "re-distribute" the values between
the two pointers,  and  so the invariant 
could be restored.
It should be clear by this moment, that, even though the proof is
proportional to the size of the program, it has combined some
mathematical reasoning with a machinery of consistent rule
application, until the postcondition has been reached, which, when
done by a human solely, might be an error-prone
procedure. Nevertheless, this proof process is very reminiscent to the
proofs that we have seen so far in Coq, when one gradually applies the
lemmas, assumptions and performs rewritings until the final goal is
proved. This is why using Coq seems like a good idea to mechanize the
process of proofs in separation logic, so one can be sure that there
is nothing missed during the reasoning process and the specification
is certainly correct. Employing Coq for this purpose is indeed our
ultimate goal and the topic of this chapter. However, before we reach
that point, let us recall that in a nutshell Coq is in fact a
<i>functional</i> programming language and make yet another short detour to
the world of pure functional programming, to see how effects might be
specified by means of <i>types</i>.
<a name="lab79"></a><h1 class="section">Specifying effectful computations using types</h1>



In imperative programs there is a significant distinction between
<i>expressions</i> and <i>programs</i> (or <i>commands</i>). While the former ones
are <i>pure</i>, i.e., will always evaluate to the same result, by which
they can be safely replaced, the latter ones are <i>effectful</i>, as their
result and the ultimate outcome may produce some irreversible effect
(e.g., mutating references, throwing exceptions, performing output or
reading from input), which one should account for. Hoare logics, and,
in particular, separation logic focus on specifying effectful programs
taking expressions for granted and assuming their referential
transparency, which makes it not entirely straightforward to embed
such reasoning into the purely functional setting of the Coq
framework.
It has been a long-standing problem for the functional programming
community to reconcile the <i>pure</i> expressions, enjoying referential
transparency, with effectful computations, until Eugenio Moggi
suggested to use the mechanism of <i>monads</i> to separate the <i>results</i>
of computations from the possible <i>effects</i> they can
produce, and Philip Wadler popularized this idea
with a large number of examples, as it was
adopted in the same time by the Haskell programming language. There is
a countless number of tutorials written and available on the Web that
are targeted to help building the intuition about the "monad
magic". Although grasping some essence of monadic computations is
desirable for understanding how verification of the imperative
programs can be structured in Coq, providing the reader with yet
another "monad tutorial" is not the task of this course. Luckily, in
order to proceed to the verification in separation logic, which is the
topic of this chapter, we need only very basic intuition on what
monads are, and how they are typically used to capture the essence of
computations and their effects.
<a name="lab80"></a><h2 class="section">On monads and computations</h2>


While presenting rules for Hoare and separation logic, we have seen a
number of operators, allowing to construct larger programs from
smaller ones: conditionals, loops, binding, etc. However, only two of
the connectives are inherent to imperative programming and make it
distinct from the programming with pure functions:



<ul class="doclist">
<li> <i>Binding</i> (i.e., a program of the form ) is a way
  to specify that the effect of the computation  takes place
  strictly <i>before</i> the computation  is executed. Following its
  name this program constructor also performs binding of the (pure)
  result of the first computation, so it can be substituted to all
  occurrences of  in the second command, . In this sense,
  binding is different from expressions of the form <span class="inlinecode"><span class="id" title="keyword">let</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">e1</span></span> <span class="inlinecode"><span class="id" title="tactic">in</span></span>
  <span class="inlinecode"><span class="id" title="var">e2</span></span>, omnipresent in functional programs, as the latter ones might allow
  for both strict and lazy evaluation of the right-hand side
  expression <span class="inlinecode"><span class="id" title="var">e1</span></span> depending on a semantics of the language (e.g.,
  call-by-value in Standard ML vs. call-by-need in Haskell). This
  flexibility does not affect the result of a pure program (modulo
  divergence), since <span class="inlinecode"><span class="id" title="var">e1</span></span> and <span class="inlinecode"><span class="id" title="var">e2</span></span> are expressions, and, hence, are
  pure. However, in the case of computations, the order should be
  fixed and this is what the binding construct serves for.

</li>
<li> <i>Returning</i> a value is a command constructor (which we typeset as
  ), which allows one to embed a pure expression into the realm
  of computations. Again, intuitively, this is explained by the fact
  that expressions and commands should be distinguished
  semantically,
  but sometimes an expression should be treated as a command (with a
  trivial effect or none of it at all), whose result is the very same
  expression.

</li>
</ul>
These two connectives, allowing one to construct the programs by means
of binding and embedding expressions into them are captured precisely
by the  interface, expressed, for instance, in Haskell
via the following type class:

The signature specifies that each instance of  is
parametrized by one type and requires two functions to be implemented.
The  function is pronounced as <i>bind</i> and describes how
a particular monad instance <i>combines</i> two computations, such that the
second one, whose type is , may depend on the value of
result of the first one, whose type is . The result of
the overall computation is then the one of the second component, namely,
. The function  specifies how to
provide a "default" value for an effectful computation, i.e., how to
"pair" a value of type  with an "effect" entity in order
to receive an element of .


In this specification, the type  serves as a generic
placeholder of the effect, whose nature is captured by the monad. As it
has been already pointed out, such effect might be a mutable state,
exceptions, explicit control, concurrency or input/output (all
captured by specific instances of monads in
Haskell), as well as the fact of program
 non-termination (i.e., <i>divergence</i>), which
Haskell deliberately does not capture. In a more informal language,
the monadic type  indicates that in the program "something
fishy is going on, besides the result being computed", so this type
serves as a mechanism, which is used by the type checker to make sure
that only programs with the <i>same</i> effect are composed together by
means of binding (hence the type of the bind operator in the
 type class). This is an important insight, which will be
directly used in the design of the verification methodology of
imperative programs using dependent types, as we will see in
.
<a name="lab81"></a><h2 class="section">Monadic do-notation</h2>

Since composing effectful/monadic computations is a very common
operation in Haskell, the language provides a convenient <span class="inlinecode"><span class="id" title="tactic">do</span></span>-notation
to write programs in a  monadic style, such that
the invocation of the bind function in the expression of the form
, where  might
occur in , can be written as .

For example, the program below is composed of several computations
within the  monad, which indicates that the possible
effect of the program, which has  in its type, can be
reading from input or writing into the output
stream.

<pre>
main = do putStrLn "Enter a character"
          c &lt;- getChar 
          putStrLn $ "\nThe character was: " ++ [c] 
          return ()
</pre>
The computations involved in the program, are represented, in
particular, by the Haskell commands (i.e., monadically-typed function
call) <span class="inlinecode"><span class="id" title="var">putStrLn</span></span> <span class="inlinecode">&quot;<span class="id" title="var">Enter</span></span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> <span class="inlinecode"><span class="id" title="var">character</span>&quot;</span>, which prints a string to the
output stream, and the call to <span class="inlinecode"><span class="id" title="var">getChar</span></span>, which reads a caracter from
the input stream. All these computations are bound using the
 syntax and <span class="inlinecode"><span class="id" title="tactic">do</span></span>-notation, and the last one returns an
embedded unit value , so the type of the whole program
 is inferred to be .
<a name="lab82"></a><h1 class="section">Elements of Hoare Type Theory</h1>


At this point we have acquired a number of important insights that
should lead us to the idea of implementing verification of effectful
imperative programs in Coq:
<ul class="doclist">
<li> Hoare specifications in separation logic behave like types of the
  computations they specify, which is witnessed by the rules of
  weakening , function and application specification
  inference  and  and recursive functions
    Moreover, since
  pre- and postconditions can depend on the values of logical
  universally-quantified variables as well as on the values of the
  command's arguments, Hoare-style specs are in fact instances of
  <i>dependent</i> types.

</li>
<li> Hoare triples in separation logic specify <i>effectful</i> computations
  that are composed using the <i>binding</i> mechanism, with pure
  expressions being injected into them by means of "wrapping" them
  with a  operator. This makes Hoare triples behave exactly like
  instances of <i>monads</i> from functional programming, whose composition
  is described by, e.g., the  type class from Haskell.

</li>
<li> Effectful computations can take effects, which should be accounted
  for in their specifications. The effects (or observation of an
  effectful state) are due to some dedicated operations, such as
  <i>pointer assignment</i>, <i>pointer reading</i>, <i>allocation</i> or
  <i>deallocation</i>. These operations come with dedicated specifications,
  similarly to how operations  and  in
  Haskell are typed with respect to the  monad, whose state
  they modify.

</li>
<li> Another important effect, which has no explicit handling in the
  mainstream programming languages like Haskell, but should be dealt
  with in the context of pure, strongly-normalizing language of Coq,
  is <i>divergence</i>. We cannot allow one to have potentially
  non-terminating computations as expressions in Coq (i.e., those
  implemented by means of the general recursion operator  from
  ), but we can afford having a monadic type
  of computations such that they might possibly diverge <i>if</i> they are
  executed (and, even though, they will not be executed within Coq,
  they can still be type-checked, and, hence, verified). Therefore,
  monadic encoding of the fixpoint operator provides a way to escape
  the termination-checking conundrum and encode nonterminating
  programs in Coq.

</li>
</ul>


All these observation resulted in a series of works on <i>Hoare Type
Theory</i> (or just HTT), which defines a notion of an <i>indexed Hoare
monad</i> (or, <i>Hoare type</i>) as a mechanism to encode Hoare-style
specifications as dependent types and reduce the verification of
effectful progress to proving propositions in
Coq.
In the rest of this chapter we will consider a number of important
concepts of HTT, so the necessary modules should be imported from the
library folder <span class="inlinecode"><span class="id" title="var">htt</span></span>, which contains the compiled files (see
Section for the instructions on obtaining and
building HTT from the sources).

<div class="paragraph"> </div>


<div class="paragraph"> </div>



</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">mathcomp</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">ssreflect</span> <span class="id" title="library">ssrbool</span> <span class="id" title="library">ssrnat</span> <span class="id" title="library">eqtype</span> <span class="id" title="library">seq</span> <span class="id" title="library">ssrfun</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">fcsl</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">prelude</span> <span class="id" title="library">pred</span> <span class="id" title="library">pcm</span> <span class="id" title="library">unionmap</span> <span class="id" title="library">heap</span>.<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">HTT</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">stmod</span> <span class="id" title="library">stsep</span> <span class="id" title="library">stlog</span> <span class="id" title="library">stlogR</span>.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="HTT"><span class="id" title="module">HTT</span></a>.<br/>

<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="keyword">Strict</span> <span class="id" title="keyword">Implicit</span>.<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="keyword">Printing</span> <span class="id" title="keyword">Implicit</span> <span class="id" title="var">Defensive</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab83"></a><h2 class="section">The Hoare monad</h2>



The Hoare monad (also dubbed as Hoare type), which is a type of
result-returning effectful computations with pre- and postconditions
is represented in HTT by the type <span class="inlinecode"><span class="id" title="var">STsep</span></span>, which is, in fact, just a
notation for a more general but less tractable type <span class="inlinecode"><span class="id" title="var">STspec</span></span>, whose
details we do not present here, as they are quite technical and are
not necessary in order to verify programs in HTT.<span class="inlinecode"><span class="id" title="library">stmod</span></span>

The Hoare type is usually specified using the HTT-provided notation as
<span class="inlinecode">{<span class="id" title="var">x1</span></span> <span class="inlinecode"><span class="id" title="var">x2</span></span> <span class="inlinecode">...},</span> <span class="inlinecode"><span class="id" title="var">STsep</span></span> <span class="inlinecode">(<a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>,</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a>)</span>, where <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a></span> are the predicates,
corresponding to the pre and postcondition with <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> being of type
<span class="inlinecode"><span class="id" title="library">heap</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a></span> of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="library">heap</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, such that <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> is
the type of the result of the command being specified. The identifiers
<span class="inlinecode"><span class="id" title="var">x1</span></span>, <span class="inlinecode"><span class="id" title="var">x2</span></span> etc. bind the logical variables that are assumed to be
universally quantified and can appear freely in <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a></span>, similarly
to the free variables in the specifications in Hoare logics
(). For example, the 
function has the following (simplified compared to the original one)
small footprint specification in the <span class="inlinecode"><span class="id" title="var">STsep</span></span>-notation:
<br/>
<span class="inlinecode"><span class="id" title="definition">alloc</span> : <span class="id" title="keyword">∀</span> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">STsep</span> (<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">vfun</span> (<a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> : <span class="id" title="inductive">ptr</span>) <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>])
<div class="paragraph"> </div>

</span>
That is, alloc is a procedure, which starts in an empty heap <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a></span>
and whose argument <span class="inlinecode"><a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a></span> of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> becomes referenced by the pointer
(which is also the <span class="inlinecode"><span class="id" title="definition">alloc</span></span>'s result) in the resulting
singleton-pointer heap. The notation <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">:-&gt;</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> corresponds to the
points-to assertion  in the mathematical representation
of separation logic, and <span class="inlinecode">[<span class="id" title="var">vfun</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode">...]</span> notation accounts for the
fact that the computation can throw an
exception, the possibility we do not
discuss in this course.
<a name="lab84"></a><h2 class="section">Structuring program verification in HTT</h2>

Let us now consider how the examples from 
can be given specifications and verified in Coq. The program on
page, which modifies a pointer <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and keeps a
different pointer <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> intact can be given the following spec:

</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Program Definition</span> <a name="HTT.alter_x"><span class="id" title="definition">alter_x</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">x</span> : <span class="id" title="inductive">ptr</span>) (<span class="id" title="var">v</span> : <a class="idref" href="PnP.HTT.html#A"><span class="id" title="variable">A</span></a>): <br/>
&nbsp;&nbsp;<span class="id" title="notation">{</span><span class="id" title="var">y</span> (<span class="id" title="var">Y</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><span class="id" title="notation">)},</span> <br/>
&nbsp;&nbsp;<span class="id" title="notation">STsep</span> <span class="id" title="notation">(</span><span class="id" title="keyword">fun</span> <span class="id" title="var">h</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <span class="id" title="var">B</span> (<span class="id" title="var">w</span> : <a class="idref" href="PnP.HTT.html#B"><span class="id" title="variable">B</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">),</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> <span class="id" title="notation">\+</span> <a class="idref" href="PnP.HTT.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a><span class="id" title="notation">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">[</span><span class="id" title="notation">vfun</span> <span class="id" title="notation">(</span><span class="id" title="var">_</span><span class="id" title="notation">:</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a><span class="id" title="notation">)</span> <span class="id" title="var">h</span> <span class="id" title="notation">⇒</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> <span class="id" title="notation">\+</span> <a class="idref" href="PnP.HTT.html#y"><span class="id" title="variable">y</span></a> <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a><span class="id" title="notation">]</span><span class="id" title="notation">)</span> := <br/>
&nbsp;&nbsp;<span class="id" title="notation">Do</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">::=</span> <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">

The Coq command  <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> is similar to the
standard definition <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> except for the fact that it allows
the expression being defined to have a type, some of whose components
haven't yet been type-checked and remain to be filled by the
programmer, similarly to Agda's  incremental
development. That is, based on the expression
itself (<span class="inlinecode"><span class="id" title="var">Do</span></span> <span class="inlinecode">(<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>)</span>), Coq will infer <i>the most general type</i> that
the expression can be allowed to have, and then it becomes a
programmer's <i>obligation</i> to show that the declared type is actually a
specialization of the inferred type. In the context of HTT,
the type, inferred by Coq based on the definition, can be seen
as a specification with the <i>weakest pre</i> and <i>strongest
postconditions</i>, which can then be weakened via the 
rule. The program itself is wrapped into the <span class="inlinecode"><span class="id" title="var">Do</span></span>-notation, which is
provided by the HTT library and indicates that the computations inside
always deal with the <span class="inlinecode"><span class="id" title="var">STsep</span></span> type, similar to the Haskell's treatment
of <span class="inlinecode"><span class="id" title="tactic">do</span></span>-notation.

The type of the program <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.alter_x"><span class="id" title="definition">alter_x</span></a></span> is specified explicitly via the
<span class="inlinecode"><span class="id" title="var">STsep</span></span>-notation. There are two logical variables: the pointer <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> and
the value <span class="inlinecode"><a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a></span> of type <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, which is referenced by <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span>. The
precondition states the existence of some type <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> and value <span class="inlinecode"><a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a></span>, such
that <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> points to it. The postcondition specifies that the result is
of type <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span> (and, therefore, is unconstrained), and the content of
the pointer <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> became <span class="inlinecode"><a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a></span>, while the content of the pointer <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span>
remained unchanged. Notice that we make explicit use of the PCM
notation () for the empty heap, which is
paraphrased as <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a></span> and for the disjoint union of heaps, which is
expressed through the join operator <span class="inlinecode">\+</span>.
After stating the definition, Coq generates a series of obligations to
prove in order to establish the defined program well-typed with
respect to the stated type.
<br/>
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.alter_x"><span class="id" title="definition">alter_x</span></a> <span class="id" title="var">has</span> <span class="id" title="keyword">type</span>-<span class="id" title="var">checked</span>, <span class="id" title="var">generating</span> 1 <span class="id" title="var">obligation</span>(<a class="idref" href="PnP.FunProg.html#s"><span class="id" title="variable">s</span></a>)<br/>
<span class="id" title="var">Solving</span> <span class="id" title="var">obligations</span> <span class="id" title="var">automatically</span>...<br/>
1 <span class="id" title="var">obligation</span> <span class="id" title="var">remaining</span><br/>
<span class="id" title="keyword">Obligation</span> 1 <span class="id" title="keyword">of</span> <a class="idref" href="PnP.HTT.html#HTT.alter_x"><span class="id" title="definition">alter_x</span></a>:<br/>
<span class="id" title="keyword">∀</span> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <span class="id" title="inductive">ptr</span>) (<a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>),<br/>
<span class="id" title="definition">conseq</span> (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> ::= <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;(<span class="id" title="var">logvar</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <span class="id" title="inductive">ptr</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">logvar</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">binarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> : <span class="id" title="library">heap</span> ⇒ <span class="id" title="tactic">∃</span> (<a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>), <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> \+ <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">vfun</span> <span class="id" title="var">_</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> \+ <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a>]))).
<div class="paragraph"> </div>

</span>The statement looks rather convoluted due to a number of type
definitions and notations used and essentially postulates that from
the proposition, corresponding to the specification inferred by Coq
from the program definition, we should be able to prove the
specification that we have declared explicitly. Instead of explaining
each component of the goal, we will proceed directly to the proof and
will build the necessary intuition as we go.
The proof mode for each of the remaining obligations is activated by
the Vernacular command <span class="inlinecode"><span class="id" title="keyword">Next</span></span> <span class="inlinecode"><span class="id" title="keyword">Obligation</span></span>, which automatically moves
some of the assumptions to the context.


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Next</span> <span class="id" title="keyword">Obligation</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <span class="id" title="inductive">ptr</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="definition">conseq</span> (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> ::= <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="var">logvar</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <span class="id" title="inductive">ptr</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">logvar</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">binarify</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> : <span class="id" title="library">heap</span> ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">∃</span> (<a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>), <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> \+ <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">vfun</span> <span class="id" title="var">_</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> \+ <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a>])))
<div class="paragraph"> </div>

</span>A usual first step in every HTT proof, which deals with a spec with
logical variables is to "pull them out", so they would just become
simple assumptions in the goal, allowing one to get rid of the
<span class="inlinecode"><span class="id" title="var">logvar</span></span> and <span class="inlinecode"><span class="id" title="var">binarify</span></span> calls in the goal.<span class="inlinecode"><span class="id" title="var">logvar</span></span><span class="inlinecode"><span class="id" title="var">binarify</span></span> This is what is done by
applying the lemma <span class="inlinecode"><span class="id" title="lemma">ghR</span></span>  to the goal.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="lemma">ghR</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <span class="id" title="inductive">ptr</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<span class="id" title="var">i</span> : <span class="id" title="library">heap</span>) (<span class="id" title="var">x0</span> : <span class="id" title="inductive">ptr</span> × <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" title="tactic">∃</span> (<a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>), <span class="id" title="var">i</span> = <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> \+ <span class="id" title="var">x0</span>.1 :-&gt; <span class="id" title="var">x0</span>.2) →<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> <span class="id" title="var">i</span> → <span class="id" title="abbreviation">verify</span> <span class="id" title="var">i</span> (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> ::= <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>) [<span class="id" title="var">vfun</span> <span class="id" title="var">_</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> \+ <span class="id" title="var">x0</span>.1 :-&gt; <span class="id" title="var">x0</span>.2]
<div class="paragraph"> </div>

</span>We can now move a number of assumptions, arising from the "brushed"
specification, to the context, along with some rewriting by equality
and simplifications.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>⇒<span class="id" title="var">h1</span> [<span class="id" title="var">y</span> <span class="id" title="var">Y</span>][<span class="id" title="var">B</span>][<span class="id" title="var">w</span>]-&gt;{<span class="id" title="var">h1</span>} <span class="id" title="var">_</span> /=.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="abbreviation">verify</span> (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a> \+ <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a>) (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> ::= <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>) [<span class="id" title="var">vfun</span> <span class="id" title="var">_</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> \+ <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a>]
<div class="paragraph"> </div>

</span>
The resulting goal is stated using the <span class="inlinecode"><span class="id" title="abbreviation">verify</span></span>-notation, which means
that in this particular case, in the heap of the shape <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">:-&gt;</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#w"><span class="id" title="variable">w</span></a></span> <span class="inlinecode">\+</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span>
<span class="inlinecode">:-&gt;</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a></span> we need to be able to prove that the result and the produced
heap of the command <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">::=</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a></span> satisfy the predicate <span class="inlinecode">[<span class="id" title="var">vfun</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span> <span class="inlinecode">=</span>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">:-&gt;</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a></span> <span class="inlinecode">\+</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> <span class="inlinecode">:-&gt;</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a>]</span>. This goal can be proved using one of the
numerous <span class="inlinecode"><span class="id" title="abbreviation">verify</span></span>-lemmas that HTT provides (try executing <span class="inlinecode"><span class="id" title="keyword">Search</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span>
<span class="inlinecode">(<span class="id" title="abbreviation">verify</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span>)</span> to see the full list), however in this particular case
the program and the goal are so simple and are obviously correct that
the statement can be proved by means of proof automation, implemented
in HTT by a brute-force tactic <span class="inlinecode"><span class="id" title="var">heval</span></span>, which just tries a number of
<span class="inlinecode"><span class="id" title="abbreviation">verify</span></span>-lemmas applicable in this case modulo the shape of the heap.


</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="var">heval</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab85"></a><h2 class="section">Verifying the factorial procedure mechanically</h2>


Proving an assignment for two non-aliased pointers was a simple
exercise, so now we can proceed to a more interesting program, which
features loops and conditional expressions, namely, imperative
implementation of the factorial function.
Our specification and verification process will follow precisely the
story of . We start by defining the
factorial in the most declarative way---as a pure recursive function
in Coq itself.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <span class="id" title="var">n</span> := <span class="id" title="keyword">if</span> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">n'</span><span class="id" title="notation">.+1</span> <span class="id" title="keyword">then</span> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">×</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#fact_pure"><span class="id" title="definition">fact_pure</span></a> <span class="id" title="var">n'</span><span class="id" title="notation">)</span> <span class="id" title="keyword">else</span> 1.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Next, we define the loop invariant <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a></span>, which constraints the
heap shape and the values of the involved pointers, <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span>,
mimicking precisely the definition of :

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">acc</span> : <span class="id" title="inductive">ptr</span>) (<span class="id" title="var">N</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) <span class="id" title="var">h</span> : <span class="id" title="keyword">Prop</span> := <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <span class="id" title="var">n'</span> <span class="id" title="var">a'</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#53e4c1e546d9b20e029d981f761726c2"><span class="id" title="notation">[/\</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="notation">\+</span> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#53e4c1e546d9b20e029d981f761726c2"><span class="id" title="notation">&amp;</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#n'"><span class="id" title="variable">n'</span></a><span class="id" title="notation">)</span> <span class="id" title="notation">×</span> <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#53e4c1e546d9b20e029d981f761726c2"><span class="id" title="notation">]</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

To show how separation logic, in general and its particular
implementation in HTT, allows one to build the reasoning
<i>compositionally</i> (i.e., by building the proofs about large programs
from the facts about their components), we will first provide and
prove a specification for the internal factorial loop, which, in fact,
performs all of the interesting computations, so the rest of the
"main" function only takes care of allocation/deallocation of the
pointers <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span>. The loop will be just a function, taking an
argument of the type unit and ensuring the invariant <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a></span> in its
pre- and postcondition, as defined by the following type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a></span>,
parametrized by the pointers <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span>.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a> <span class="id" title="var">n</span> <span class="id" title="var">acc</span> := <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="notation">{</span><span class="id" title="var">N</span><span class="id" title="notation">},</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">STsep</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><span class="id" title="notation">,</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">[</span><span class="id" title="notation">vfun</span> <span class="id" title="notation">(</span><span class="id" title="var">res</span> <span class="id" title="notation">:</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><span class="id" title="notation">)</span> <span class="id" title="var">h</span> <span class="id" title="notation">⇒</span> <a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><span class="id" title="notation">]</span><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a></span> ensures additionally that the resulting value is in
fact a factorial of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span>, which is expressed by the conjunct <span class="inlinecode"><a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a></span> <span class="inlinecode">=</span>
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span>. 


The definition of the factorial "accumulator" loop is then represented
as a recursive function, taking as arguments the two pointers, <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span>, and also a unit value. The body of the function is defined
using the monadic fixpoint operator <span class="inlinecode"><span class="id" title="keyword">Fix</span></span>, whose semantics
is similar to the semantics of the classical <i>Y-combinator</i>, defined
usually by the equation <span class="inlinecode"><a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> <span class="inlinecode">(<a class="idref" href="PnP.HTT.html#Y"><span class="id" title="variable">Y</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a>)</span>, where <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> is a fixpoint
operator argument that should be thought of as a recursive function
being defined. Similarly, the fixpoint operator <span class="inlinecode"><span class="id" title="keyword">Fix</span></span>, provided by
HTT, takes as arguments a function, which is going to be called
recursively (<span class="inlinecode"><a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a></span>, in this case), its argument and <i>body</i>. The named
function (i.e., <span class="inlinecode"><a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a></span>) can be then called from the body recursively.
In the similar spirit, one can define nested loops in HTT as nested
calls of the fixpoint operator.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Program Definition</span> <a name="HTT.fact_acc"><span class="id" title="definition">fact_acc</span></a> (<span class="id" title="var">n</span> <span class="id" title="var">acc</span> : <span class="id" title="inductive">ptr</span>): <a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> := <br/>
&nbsp;&nbsp;<span class="id" title="definition">Fix</span> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">loop</span> : <a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a>) (<span class="id" title="var">_</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#unit"><span class="id" title="inductive">unit</span></a>) ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">Do</span> <span class="id" title="notation">(</span><span class="id" title="var">a1</span> <span class="id" title="notation">&lt;--</span> <span class="id" title="definition">read</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a><span class="id" title="notation">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">n'</span> <span class="id" title="notation">&lt;--</span> <span class="id" title="definition">read</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a><span class="id" title="notation">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">if</span></a> <a class="idref" href="PnP.HTT.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="notation">==</span> 0 <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">then</span></a> <span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#a1"><span class="id" title="variable">a1</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">else</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <span class="id" title="notation">::=</span> <a class="idref" href="PnP.HTT.html#a1"><span class="id" title="variable">a1</span></a> <span class="id" title="notation">×</span> <a class="idref" href="PnP.HTT.html#n'"><span class="id" title="variable">n'</span></a><span class="id" title="notation">;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <span class="id" title="notation">::=</span> <a class="idref" href="PnP.HTT.html#n'"><span class="id" title="variable">n'</span></a> <span class="id" title="notation">-</span> 1<span class="id" title="notation">;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><span class="id" title="notation">)</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The body of the accumulator loop function reproduces precisely the
factorial implementation in pseudocode from page. It first reads the values of
the pointers <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> into the local variables <span class="inlinecode"><a class="idref" href="PnP.HTT.html#a1"><span class="id" title="variable">a1</span></a></span> and
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a></span>. Notice that the binding of the local immutable variables is
represented by the <span class="inlinecode">&lt;--</span> notation, which corresponds to the <i>bind</i>
operation of the Hoare monad <span class="inlinecode"><span class="id" title="var">STsep</span></span>. The function then uses Coq's
standard conditional operator and returns a value of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#a1"><span class="id" title="variable">a1</span></a></span> if <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a></span> is
zero using the monadic <span class="inlinecode"><span class="id" title="definition">ret</span></span> operator.  In the case of
<span class="inlinecode"><span class="id" title="keyword">else</span></span>-branch, the new values are written to the pointers <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span> and
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span>, after which the function recurs.
Stating the looping function like this leaves us with one obligation
to prove.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Next</span> <span class="id" title="keyword">Obligation</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

As in the previous example, we start by transforming the goal, so the
logical variable <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span>, coming from the specification of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a></span> would
be exposed as an assumption. We immediately move it to the context
along with the initial heap <span class="inlinecode"><span class="id" title="var">i</span></span>.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="lemma">ghR</span>⇒<span class="id" title="var">i</span> <span class="id" title="var">N</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<span class="id" title="var">i</span> : <span class="id" title="library">heap</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> <span class="id" title="var">i</span> →<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> <span class="id" title="var">i</span> →<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="abbreviation">verify</span> <span class="id" title="var">i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PnP.HTT.html#a1"><span class="id" title="variable">a1</span></a> &lt;-- ! <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> &lt;-- ! <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">if</span> <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> == 0 <span class="id" title="keyword">then</span> <span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#a1"><span class="id" title="variable">a1</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> ::= <a class="idref" href="PnP.HTT.html#a1"><span class="id" title="variable">a1</span></a> × <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a>;; <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> ::= <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> - 1;; <a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a> <a class="idref" href="PnP.FunProg.html#tt"><span class="id" title="constructor">tt</span></a>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">vfun</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ∧ <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a>]
<div class="paragraph"> </div>

</span>We next case-analyse on the top assumption with the invariant
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a></span> to acquire the equality describing the shape of the heap
<span class="inlinecode"><span class="id" title="var">i</span></span>. We then rewrite <span class="inlinecode"><span class="id" title="var">i</span></span> in place and move a number of hypotheses to
the context.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">case</span>⇒<span class="id" title="var">n'</span> [<span class="id" title="var">a'</span>][-&gt;{<span class="id" title="var">i</span>}] <span class="id" title="var">Hi</span> <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
Now the goal has the shape <span class="inlinecode"><span class="id" title="abbreviation">verify</span></span> <span class="inlinecode">(<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode">:-&gt;</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a></span> <span class="inlinecode">\+</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span> <span class="inlinecode">:-&gt;</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a>)</span> <span class="inlinecode">...</span>,
which is suitable to be hit with the automation by means of the
<span class="inlinecode"><span class="id" title="var">heval</span></span>  tactic, progressing the goal to the state when
we should reason about the conditional operator.

</div>
<div class="code">

<br/>
<span class="id" title="var">heval</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">Hi</span> : <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> × <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="abbreviation">verify</span> (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> :-&gt; <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> \+ <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">if</span> <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> == 0 <span class="id" title="keyword">then</span> <span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> <span class="id" title="keyword">else</span> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> ::= <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> × <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a>;; <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> ::= <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> - 1;; <a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a> <a class="idref" href="PnP.FunProg.html#tt"><span class="id" title="constructor">tt</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">vfun</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ∧ <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a>]
<div class="paragraph"> </div>

</span>The goal, containing a use of the conditional operator, is natural to
be proved on case analysis on the condition <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a></span> <span class="inlinecode">==</span> <span class="inlinecode">0</span>.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">case</span> <span class="id" title="var">X</span>: (<span class="id" title="var">n'</span> <span class="id" title="notation">==</span> 0).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Now, the first goal has the form 
<br/>
<span class="inlinecode">&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<span class="id" title="var">Hi</span> : <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> × <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">X</span> : (<a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> == 0) = <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="abbreviation">verify</span> (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> :-&gt; <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> \+ <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> :-&gt; <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a>) (<span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">vfun</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ∧ <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a>]
<div class="paragraph"> </div>

</span>To prove it, we will need one of the numerous <span class="inlinecode"><span class="id" title="var">val</span></span>-lemmas, delivered
as a part of HTT libraries and directly corresponding to the rules of
separation logic (). The general
recipe on acquiring intuition for the lemmas applicable for each
particular <span class="inlinecode"><span class="id" title="abbreviation">verify</span></span>-goal is to make use of Ssreflect's <span class="inlinecode"><span class="id" title="keyword">Search</span></span>
machinery. For instance, in this particular case, given that the
command to be verified (i.e., the second argument of <span class="inlinecode"><span class="id" title="abbreviation">verify</span></span>) is <span class="inlinecode"><span class="id" title="definition">ret</span></span>
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a></span>, let us try the following query.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Search</span> <span class="id" title="var">_</span> (<span class="id" title="abbreviation">verify</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>) (<span class="id" title="definition">ret</span> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">
The request results report, in particular, on the following lemma
found:
<br/>
<span class="inlinecode"><span class="id" title="lemma">val_ret</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>) (<span class="id" title="var">i</span> : <span class="id" title="var">heapPCM</span>) (<a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> : <span class="id" title="var">cont</span> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>),<br/>
&nbsp;&nbsp;&nbsp;(<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> <span class="id" title="var">i</span> → <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> (<span class="id" title="var">Val</span> <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>) <span class="id" title="var">i</span>) → <span class="id" title="abbreviation">verify</span> <span class="id" title="var">i</span> (<span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#v"><span class="id" title="variable">v</span></a>) <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a>
<div class="paragraph"> </div>

</span>The lemma has a statement in its conclusion, which seems like it can
be unified with our goal, so we proceed by applying it.


</div>
<div class="code">

<br/>
- <span class="id" title="tactic">apply</span>: <span class="id" title="lemma">val_ret</span>=&gt;/= <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The remaining part of the proof of this goal has absolutely nothing to
do with program verification and separation logic and accounts to
combining a number of arithmetical facts in the goal via the
hypotheses <span class="inlinecode"><span class="id" title="var">Hi</span></span> and <span class="inlinecode"><span class="id" title="var">X</span></span>. We proceed by first turning boolean
equality in <span class="inlinecode"><span class="id" title="var">X</span></span> into propositional via the view <span class="inlinecode"><span class="id" title="lemma">eqP</span></span> and then
substituting all occurrences of <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a></span> in the goal and other assumptions
via Coq's tactic <span class="inlinecode"><span class="id" title="tactic">subst</span></span>. The rest of the proof is by providing
existential witnesses and rewriting <span class="inlinecode">1</span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a></span> to <span class="inlinecode"><a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a></span> in <span class="inlinecode"><span class="id" title="var">Hi</span></span>.
 

</div>
<div class="code">

<br/>
&nbsp;&nbsp;<span class="id" title="tactic">move</span>/<span class="id" title="lemma">eqP</span>: <span class="id" title="var">X</span>⇒<span class="id" title="var">Z</span>; <span class="id" title="tactic">subst</span> <span class="id" title="var">n'</span>.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">split</span>; <span class="id" title="tactic">first</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">∃</span> 0, <span class="id" title="var">a'</span>=&gt;//.<br/>
&nbsp;&nbsp;<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">mul1n</span> <span class="id" title="tactic">in</span> <span class="id" title="var">Hi</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The second goal requires satisfying the specification of a sequence of
assignments, which can be done automatically using the <span class="inlinecode"><span class="id" title="var">heval</span></span> tactic.

</div>
<div class="code">

<br/>
<span class="id" title="var">heval</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a> : <a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a><br/>
&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<span class="id" title="var">Hi</span> : <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> × <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">X</span> : (<a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> == 0) = <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="abbreviation">verify</span> (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> :-&gt; (<a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> - 1) \+ <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> :-&gt; (<a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> × <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a>)) (<a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a> <a class="idref" href="PnP.FunProg.html#tt"><span class="id" title="constructor">tt</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="id" title="var">vfun</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ∧ <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a>]
<div class="paragraph"> </div>

</span>The next step is somewhat less obvious, as we need to prove the
specification of the recursive call to <span class="inlinecode"><a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a></span>, whose spec is also
stored in our assumption context. Before we can apply a lemma, which
is an analogue of the , we need to <i>instantiate</i> the
logical variables of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a></span>'s specification (which is described by the
type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a></span>). The spec <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a></span> features only one logical variable,
namely <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span>, so we provide it using the HTT lemma <span class="inlinecode"><span class="id" title="lemma">gh_ex</span></span>.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: (<span class="id" title="lemma">gh_ex</span> <span class="id" title="var">N</span>).<br/>

<br/>
</div>

<div class="doc">
Now to verify the call to <span class="inlinecode"><a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a></span>, we can apply the lemma <span class="inlinecode"><span class="id" title="lemma">val_doR</span></span>,
corresponding to the rule , which will replace the goal by
the precondition from the spec <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_tp"><span class="id" title="definition">fact_tp</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span>. In HTT there are
several lemmas tackling this kind of a goal, all different in the way
they treat the postconditions, so in other cases it is recommended to
run <span class="inlinecode"><span class="id" title="keyword">Search</span></span> <span class="inlinecode">&quot;<span class="id" title="lemma">val_do</span>&quot;</span> to see the full list and chose the most
appropriate one.


</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="lemma">val_doR</span>=&gt;// <span class="id" title="var">_</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<span class="id" title="var">Hi</span> : <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> × <a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">X</span> : (<a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> == 0) = <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#HTT.fact_inv"><span class="id" title="definition">fact_inv</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> (<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> :-&gt; (<a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a> - 1) \+ <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> :-&gt; (<a class="idref" href="PnP.HTT.html#a'"><span class="id" title="variable">a'</span></a> × <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a>))
<div class="paragraph"> </div>

</span>As in the case of the previous goal, the remaining proof is focused on
proving a statement about a heap and natural numbers, so we just
present its proof below without elaborating on the details, as they
are standard and mostly appeal to propositional reasoning
(Chapter) and rewriting by lemmas from Ssreflect's
<span class="inlinecode"><span class="id" title="library">ssrnat</span></span> module.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">∃</span> (<span class="id" title="var">n'</span><span class="id" title="notation">-</span>1), (<span class="id" title="var">a'</span> <span class="id" title="notation">×</span> <span class="id" title="var">n'</span>); <span class="id" title="tactic">split</span>=&gt;//=.<br/>
<span class="id" title="tactic">rewrite</span> -<span class="id" title="var">Hi</span>=&gt;{<span class="id" title="var">Hi</span>}; <span class="id" title="tactic">rewrite</span> [<span class="id" title="var">a'</span> <span class="id" title="notation">×</span> <span class="id" title="var">_</span>]<span class="id" title="lemma">mulnC</span> <span class="id" title="lemma">mulnA</span> [<span class="id" title="var">_</span> <span class="id" title="notation">×</span> <span class="id" title="var">n'</span>]<span class="id" title="lemma">mulnC</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span>: <span class="id" title="var">n'</span> <span class="id" title="var">X</span>=&gt;//= <span class="id" title="var">n'</span> <span class="id" title="var">_</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">subn1</span> -<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Peano.html#pred_Sn"><span class="id" title="lemma">pred_Sn</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

We can now implement the main body of the factorial function, which
allocates the necessary pointers, calls the accumulator loop and then
frees the memory.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Program Definition</span> <a name="HTT.fact"><span class="id" title="definition">fact</span></a> (<span class="id" title="var">N</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <br/>
&nbsp;&nbsp;<span class="id" title="notation">STsep</span> <span class="id" title="notation">(</span><span class="id" title="notation">[</span><span class="id" title="notation">Pred</span> <span class="id" title="var">h</span> <span class="id" title="notation">|</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="abbreviation">Unit</span><span class="id" title="notation">]</span><span class="id" title="notation">,</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">[</span><span class="id" title="notation">vfun</span> <span class="id" title="var">res</span> <span class="id" title="var">h</span> <span class="id" title="notation">⇒</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="abbreviation">Unit</span><span class="id" title="notation">]</span><span class="id" title="notation">)</span> := <br/>
&nbsp;&nbsp;<span class="id" title="notation">Do</span> <span class="id" title="notation">(</span><span class="id" title="var">n</span>   <span class="id" title="notation">&lt;--</span> <span class="id" title="definition">alloc</span> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a><span class="id" title="notation">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">acc</span> <span class="id" title="notation">&lt;--</span> <span class="id" title="definition">alloc</span> 1<span class="id" title="notation">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">res</span> <span class="id" title="notation">&lt;--</span> <a class="idref" href="PnP.HTT.html#HTT.fact_acc"><span class="id" title="definition">fact_acc</span></a> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a><span class="id" title="notation">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">dealloc</span> <a class="idref" href="PnP.HTT.html#n"><span class="id" title="variable">n</span></a><span class="id" title="notation">;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">dealloc</span> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a><span class="id" title="notation">;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The specification of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact"><span class="id" title="definition">fact</span></a></span> explicitly states that its execution
starts and terminates in the empty heap; it also constraints its
result to be a factorial of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span>.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Next</span> <span class="id" title="keyword">Obligation</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Since the spec of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact"><span class="id" title="definition">fact</span></a></span> does not have any logical variables (its
postcondition only mentions its argument <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span>), there is no need to
make use of the <span class="inlinecode"><span class="id" title="lemma">ghR</span></span> lemma. However, the current goal is somewhat
obscure, so to clarify it let us unfold the definition of <span class="inlinecode"><span class="id" title="definition">conseq</span></span>
(which simply states that the consequence between the inferred type of
the program and the stated spec should be proved) and simplify the goal.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">rewrite</span> /<span class="id" title="definition">conseq</span> =&gt;/=.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">i</span> : <span class="id" title="library">heap</span>,<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">i</span> = <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a> →<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="abbreviation">verify</span> <span class="id" title="var">i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> &lt;-- <span class="id" title="definition">alloc</span> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> &lt;-- <span class="id" title="definition">alloc</span> 1;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> &lt;-- <a class="idref" href="PnP.HTT.html#HTT.fact_acc"><span class="id" title="definition">fact_acc</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a> <a class="idref" href="PnP.FunProg.html#tt"><span class="id" title="constructor">tt</span></a>; <span class="id" title="definition">dealloc</span> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>;; <span class="id" title="definition">dealloc</span> <a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a>;; <span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> (<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <span class="id" title="var">ans</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) (<a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> : <span class="id" title="library">heap</span>) ⇒<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">i</span> = <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a> → [<span class="id" title="var">vfun</span> <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> ⇒ <a class="idref" href="PnP.HTT.html#res"><span class="id" title="variable">res</span></a> = <a class="idref" href="PnP.HTT.html#HTT.fact_pure"><span class="id" title="definition">fact_pure</span></a> <a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a> ∧ <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> = <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a>] <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>)
<div class="paragraph"> </div>

</span>Next, we can rewrite the equality on the heap (which is <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a></span>) and
proceed by two runs of the <span class="inlinecode"><span class="id" title="var">heval</span></span> tactic, which will take care of the
allocated pointers yielding new assumptions <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#acc"><span class="id" title="variable">acc</span></a></span>, arising
from the implicit application of the  rule.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>⇒<span class="id" title="var">_</span> →.<br/>
<span class="id" title="var">heval</span>⇒<span class="id" title="var">n</span>; <span class="id" title="var">heval</span>⇒<span class="id" title="var">acc</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">joinC</span> <span class="id" title="lemma">unitR</span>.<br/>

<br/>
</div>

<div class="doc">
We have now came to the point when the function <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_acc"><span class="id" title="definition">fact_acc</span></a></span>, which we
have previously verified, is going to be invoked, so we need to make
use of what corresponds to the rule  again. In this case,
however, the tactic <span class="inlinecode"><span class="id" title="lemma">val_doR</span></span> will not work immediately, so we will
first need to reduce the program to be verified from the binding
command to a mere function call by means of HTT's <span class="inlinecode"><span class="id" title="lemma">bnd_seq</span></span> lemma,
which tackles the binding <i>combined</i> with a call to a user-defined
function, and this is exactly our case. Next, we instantiate the
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_acc"><span class="id" title="definition">fact_acc</span></a></span> specification's logical variable <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span> by applying <span class="inlinecode"><span class="id" title="lemma">gh_ex</span></span>
and proceed with the application of <span class="inlinecode"><span class="id" title="lemma">val_doR</span></span>.


</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="lemma">bnd_seq</span>=&gt;/=; <span class="id" title="tactic">apply</span>: (<span class="id" title="lemma">gh_ex</span> <span class="id" title="var">N</span>); <span class="id" title="tactic">apply</span>: <span class="id" title="lemma">val_doR</span>=&gt;//.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The first of the resulting two goals is an obligation arising from the
need to prove <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fact_acc"><span class="id" title="definition">fact_acc</span></a></span>'s precondition.

</div>
<div class="code">

<br/>
&nbsp;- <span class="id" title="tactic">by</span> <span class="id" title="tactic">∃</span> <span class="id" title="var">N</span>, 1; <span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">muln1</span>.<br/>

<br/>
</div>

<div class="doc">
The second goal is the remainder of the program's body, which performs
deallocation, so the proof for it is accomplished mostly by applying
<span class="inlinecode"><span class="id" title="var">heval</span></span> tactic.

</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒<span class="id" title="var">_</span> <span class="id" title="var">_</span> [[<span class="id" title="var">n'</span>][<span class="id" title="var">a'</span>][-&gt;] <span class="id" title="var">_</span> -&gt;] <span class="id" title="var">_</span>; <span class="id" title="var">heval</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


Implement in HTT a function that takes as arguments two pointers, <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>
and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span>, which point to natural numbers, and swaps their
values. Reflect this effect in the function's specification and verify
it.

<div class="paragraph"> </div>

 Instead of reading the value of a pointer into a variable <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a></span>
 using the <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a></span> <span class="inlinecode">&lt;--</span> <span class="inlinecode">!<a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> notation, you might need to specify the <i>type</i>
 of the expected value explicitly by using the "de-sugared" version of
 the command <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a></span> <span class="inlinecode">&lt;--</span> <span class="inlinecode"><span class="id" title="definition">read</span></span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span>, where <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> is the expected type. This
 way, the proof will be more straightforward.


</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">

Try to redo the exercise <i>without</i> using the
automation provided by the <span class="inlinecode"><span class="id" title="var">heval</span></span> tactic. The goal of this exercise
is to explore the library of HTT lemmas, mimicking the rules of the
separation logic. You can always display the whole list of the
available lemmas by running the command <span class="inlinecode"><span class="id" title="keyword">Search</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode">(<span class="id" title="abbreviation">verify</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span></span> <span class="inlinecode"><span class="id" title="var">_</span>)</span> and
then refine the query for specific programs (e.g., <span class="inlinecode"><span class="id" title="definition">read</span></span> or <span class="inlinecode"><span class="id" title="var">write</span></span>).


<div class="paragraph"> </div>


<div class="paragraph"> </div>




Figure presents the pseudocode listing of an
efficient imperative implementation of the function  that
computes the <span class="inlinecode"><a class="idref" href="PnP.HTT.html#N"><span class="id" title="variable">N</span></a></span>th Fibonacci number.  Your task will be to prove its
correctness with respect to the "pure" function <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.fib_pure"><span class="id" title="definition">fib_pure</span></a></span> (which you
should define in plain Coq) as well as the fact that it starts and
ends in an empty heap.

<div class="paragraph"> </div>

 What is the loop invariant of the recursive computation
 defined by means of the <span class="inlinecode"><a class="idref" href="PnP.HTT.html#loop"><span class="id" title="variable">loop</span></a></span> function?

<div class="paragraph"> </div>

 Try to decompose the reasoning into verification of several
 code pieces as in the factorial example and then composing them
 together in the "main" function.


</div>
<div class="code">

<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab86"></a><h1 class="section">On shallow and deep embeddings</h1>


A noteworthy trait of HTT's approach to verification of effectful
programs is its use of <i>shallow embedding</i> of the imperative language
 into the programming language of Coq. In
fact, the imperative programs that we have written, e.g., the
factorial procedure, are mere Coq programs, written in Coq syntax with
a number of HTT-specific notations. Moreover, the Hoare triples, by
means of which we have provided the specifications to the
heap-manipulating programs are nothing but specific types defined in
Coq. This is what makes the way effectful programs encoded <i>shallow</i>:
the new programming language of imperative programs and their
Hoare-style specifications has been defined as a subset of Coq
programming language, so most of the Coq's infrastructure for parsing,
type-checking, name binding and computations could be reused off the
shelf. In particular, shallow embedding made it possible to represent
the variables in imperative programs as Coq's variables, make use of
Coq's conditional operator and provide specifications to higher-order
procedures without going into the need to design a higher-order
version of a separation logic first (since the specifications in HTT
are just types of monadically-typed expressions). Furthermore, shallow
embedding provided us with a benefit of reusing Coq's name binding
machinery, so we could avoid the problem of <i>name capturing</i> by means
using the approach known as , representing immutable
variables by Coq's native variables (disguised by the binding notation
<span class="inlinecode">&lt;--</span>).
 
 


To summarize, shallow embedding is an approach of implementing
programming languages (not necessarily in Coq) characterized by
representation of the language of interest (usually called a
<i>domain-specific language</i> or DSL) as a subset of another
general-purpose <i>host</i> language, so the programs in the former one are
simply the programs in the latter one. The idea of shallow embedding
originated in early '60s with the beginning of the era of the Lisp
programming language, which, thanks
to its macro-expansion system, serves as a powerful platform to
implement DSLs by means of shallow embedding (such DSLs are sometimes
called <i>internal</i> or <i>embedded</i>). Shallow embedding in the world of
practical programming is advocated for a high speed of language
prototyping and the ability to re-use most of the host language
infrastructure.
An alternative approach of implementing and encoding programming
languages in general and in Coq in particular is called <i>deep
embedding</i>, and amounts to the implementation of a language of
interest from scratch, essentially, writing its parser, interpreter
and type-checker in a general-purpose language. In practice, deep
embedding is preferable when the overall performance of the
implemented language runtime is of more interest than the speed of DSL
implementation, since then a lot of intermediate abstractions, which
are artefacts of the host language, can be avoided.
In the world of mechanized program verification, both approaches, deep
and shallow embedding, have their own strengths and weaknesses.
Although implementations of deeply embedded languages and calculi
naturally tend to be more verbose, design choices in them are usually
simpler to explain and motivate. Moreover, the deep embedding approach
makes the problem of name binding to be explicit, so it would be
appreciated as an important aspect in the design and reasoning about
programming
languages. We
believe, these are the reasons why this approach is typically chosen as
a preferable one when teaching program specification and verification in
Coq.
Importantly, deep embedding gives the programming language implementor
the <i>full control</i> over its syntax and semantics. In particular, the expressivity limits of a
defined logic or a type system are not limited by expressivity of
Coq's (or any other host language's) type system. Deep embedding makes
it much more straightforward to reason about <i>pairs</i> of programs by
means of defining the relations as propositions on pairs of syntactic
trees, which are implemented as elements of corresponding datatypes.
This point, which we deliberately chose not to discuss in detail in
this course, becomes crucial when one needs to reason about the
correctness of program transformations and optimizing
compilers. In contrast, the choice of shallow
embedding, while sparing one the labor of implementing the parser,
name binder and type checker, may limit the expressivity of the
logical calculus or a type system to be defined. In the case of HTT,
for instance, it amounts to the impossibility of specifying programs that
store <i>effectful functions</i> and their specifications into a
heap.
In the past decade Coq has been used in a large number of projects
targeting formalization of logics and type systems of various
programming languages and proving their soundness, with most of them
preferring the deep embedding approach to the shallow one. We believe
that the explanation of this phenomenon is the fact that it is much
more straightforward to define semantics of a deeply-embedded
"featherweight" calculus and prove
soundness of its type system or program logic, given that it is the
<i>ultimate goal</i> of the research project. However, in order to use the
implemented framework to specify and verify realistic programs, a
significant implementation effort is required to extend the deep
implementation beyond the "core language", which makes shallow
embedding more preferable in this case---a reason why this way has
been chosen by HTT.
<a name="lab87"></a><h1 class="section">Soundness of Hoare Type Theory</h1>

Because of shallow embedding, every valid Coq program is also a valid
HTT program. However, as it has been hinted at the beginning of
, imperative programs written in HTT
cannot be simply executed, as, due to presence of general loops and
recursion, they simply may not terminate. At this point, a reader may
wonder, what good is verification of programs that cannot be run and
what is it that we have verified?
To answer this question, let us revise how the <i>soundness</i> of a Hoare
logic is defined. HTT takes definition of a Hoare triple (or, rather,
a Hoare type, since in HTT specs are types) from
page literally but implements it not via an
operational semantics, i.e., defining how a program <i>should be run</i>,
but using a denotational semantics,
i.e., defining what a program <i>is</i>. The HTT library comes with a
module <span class="inlinecode"><span class="id" title="library">stmod</span></span> that defines denotational semantics of HTT
commands and Hoare
triples, defined as types. Each command is represented by a function,
which is sometimes referred to as a <i>state transformer</i>, in the sense that
it takes a particular heap and transforms it to another heap, also
returning some result. The denotational semantics of HTT commands in
terms of state-transforming functions makes it also possible to define
what is a semantics of a program resulting from the use of the <span class="inlinecode"><span class="id" title="keyword">Fix</span></span>
operator (). The semantics of Hoare
types  is defined as
<i>sets</i> of state transforming functions, taking a heap satisfying 
to the result and heap satisfying . Therefore, the semantic account
of the verification (which is implemented by means of type-checking in
Coq) is checking that semantics of a particular HTT program (i.e., a
state-transforming function) lies <i>within</i> the semantics of its type
as a set.

If execution of programs verified in HTT is of interest, it can be
implemented by means of <i>extraction</i> of HTT commands into programs
in an external language, which supports general recursion natively
(e.g., Haskell). In fact, such extraction has been implemented in the
first release of HTT, but was not ported to
the latest release.
<a name="lab88"></a><h1 class="section">Specifying and verifying programs with linked lists</h1>

We conclude this chapter with a <i>tour de force</i> of separation logic in
HTT by considering specification and verification of programs
operating with single-linked lists. Unlike the factorial example, an
implementation of single-linked lists truly relies on pointers, and
specifying such datatypes and programs is an area where separation
logic shines.

On the surface, a single-linked list can be represented by a pointer,
which points to its head.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="HTT.llist"><span class="id" title="definition">llist</span></a> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) := <span class="id" title="inductive">ptr</span>.<br/>

<br/>
<span class="id" title="keyword">Section</span> <a name="HTT.LList"><span class="id" title="section">LList</span></a>.<br/>
<span class="id" title="keyword">Variable</span> <a name="HTT.LList.T"><span class="id" title="variable">T</span></a> : <span class="id" title="keyword">Type</span>.<br/>
<span class="id" title="keyword">Notation</span> <a name="HTT.llist"><span class="id" title="abbreviation">llist</span></a> := (<a class="idref" href="PnP.HTT.html#HTT.llist"><span class="id" title="definition">llist</span></a> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

However, in order to specify and prove interesting facts about
imperative lists, similarly to the previous examples, we need to
establish a connection between what is stored in a list heap and a
purely mathematical sequence of elements. This is done using the
<i>recursive predicate</i> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseg"><span class="id" title="definition">lseg</span></a></span>, which relates two pointers, <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a></span>,
pointing correspondingly to the head and to the tail of the list and a
logical sequence <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#xs"><span class="id" title="variable">xs</span></a></span> of elements stored in the list.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Fixpoint</span> <a name="HTT.lseg"><span class="id" title="definition">lseg</span></a> (<span class="id" title="var">p</span> <span class="id" title="var">q</span> : <span class="id" title="inductive">ptr</span>) (<span class="id" title="var">xs</span> : <span class="id" title="abbreviation">seq</span> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>): <span class="id" title="definition">Pred</span> <span class="id" title="abbreviation">heap</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">if</span> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">x</span><span class="id" title="notation">::</span><span class="id" title="var">xt</span> <span class="id" title="keyword">then</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">[</span><span class="id" title="notation">Pred</span> <span class="id" title="var">h</span> <span class="id" title="notation">|</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <span class="id" title="var">r</span> <span class="id" title="var">h'</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">:-&gt;</span> <span class="id" title="var">x</span> <span class="id" title="notation">\+</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">.+</span> 1 <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> <span class="id" title="notation">\+</span> <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a><span class="id" title="notation">)</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">In</span> <a class="idref" href="PnP.HTT.html#lseg"><span class="id" title="definition">lseg</span></a> <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> <a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a> <span class="id" title="var">xt</span><span class="id" title="notation">]</span><br/>
&nbsp;&nbsp;<span class="id" title="keyword">else</span> <span class="id" title="notation">[</span><span class="id" title="notation">Pred</span> <span class="id" title="var">h</span> <span class="id" title="notation">|</span> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="abbreviation">Unit</span><span class="id" title="notation">]</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The notation <span class="inlinecode">[<span class="id" title="definition">Pred</span></span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span> <span class="inlinecode">|</span> <span class="inlinecode">...]</span> is just an abbreviation for a function
of type <span class="inlinecode"><span class="id" title="library">heap</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, where <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span> is assumed to be of the type <span class="inlinecode"><span class="id" title="library">heap</span></span>. The
notation <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span> <span class="inlinecode">\<span class="id" title="var">In</span></span> <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> is a synonym for <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span> assuming <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> is a predicate
of type <span class="inlinecode"><span class="id" title="library">heap</span></span> <span class="inlinecode">→</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>.
The following lemma <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseg_null"><span class="id" title="lemma">lseg_null</span></a></span> states a fact, which is almost
obvious: given that the heap <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span>, corresponding to a linked list, is a
valid one (according to its notion of validity as a PCM) and the head
pointer of a list structure is <span class="inlinecode"><span class="id" title="definition">null</span></span>, then its tail pointer is <span class="inlinecode"><span class="id" title="definition">null</span></span>
as well, and the overall list is empty.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="HTT.lseg_null"><span class="id" title="lemma">lseg_null</span></a> <span class="id" title="var">xs</span> <span class="id" title="var">q</span> <span class="id" title="var">h</span> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="abbreviation">valid</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">In</span> <a class="idref" href="PnP.HTT.html#HTT.lseg"><span class="id" title="definition">lseg</span></a> <span class="id" title="definition">null</span> <a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">[/\</span></a> <a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="definition">null</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">,</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="notation">[::]</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="abbreviation">Unit</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">case</span>: <span class="id" title="var">xs</span>=&gt;[|<span class="id" title="var">x</span> <span class="id" title="var">xs</span>] <span class="id" title="var">D</span> /= <span class="id" title="var">H</span>; <span class="id" title="tactic">first</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span>: <span class="id" title="var">H</span>=&gt;&lt;- →.<br/>
<span class="id" title="tactic">case</span>: <span class="id" title="var">H</span> <span class="id" title="var">D</span>⇒<span class="id" title="var">r</span> [<span class="id" title="var">h'</span>][-&gt;] <span class="id" title="var">_</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> : <span class="id" title="inductive">ptr</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a> : <span class="id" title="library">heap</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> (<span class="id" title="definition">null</span> :-&gt; <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> \+ (<span class="id" title="definition">null</span>.+1 :-&gt; <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> \+ <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a>)) →<br/>
&nbsp;&nbsp;&nbsp;[/\ <a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a> = <span class="id" title="definition">null</span>, <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :: <a class="idref" href="PnP.SsrStyle.html#xs"><span class="id" title="variable">xs</span></a> = [::] &amp; <span class="id" title="definition">null</span> :-&gt; <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> \+ (<span class="id" title="definition">null</span>.+1 :-&gt; <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> \+ <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a>) = <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a>]
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

In the process of the proof we are forced to use the validity of a
heap in order to derive a contradiction. In the case of heap's
validity, one of the requirements is that every pointer in it is not
<span class="inlinecode"><span class="id" title="definition">null</span></span>. We can make it explicit by rewriting the top assumption with
one of the numerous HTT lemmas about heap validity (use the <span class="inlinecode"><span class="id" title="keyword">Search</span></span>
machinery to find the others).

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">validPtUn</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;...<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;[&amp;&amp; <span class="id" title="definition">null</span> != <span class="id" title="definition">null</span>, <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> (<span class="id" title="definition">null</span>.+1 :-&gt; <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> \+ <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp; <span class="id" title="definition">null</span> \<span class="id" title="var">notin</span> <span class="id" title="var">dom</span> (<span class="id" title="definition">null</span>.+1 :-&gt; <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> \+ <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a>)] →<br/>
&nbsp;&nbsp;&nbsp;[/\ <a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a> = <span class="id" title="definition">null</span>, <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> :: <a class="idref" href="PnP.SsrStyle.html#xs"><span class="id" title="variable">xs</span></a> = [::] &amp; <span class="id" title="definition">null</span> :-&gt; <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> \+ (<span class="id" title="definition">null</span>.+1 :-&gt; <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> \+ <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a>) = <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a>]
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The conjunct <span class="inlinecode"><span class="id" title="definition">null</span></span> <span class="inlinecode">!=</span> <span class="inlinecode"><span class="id" title="definition">null</span></span> in the top assumption is enough to
complete the proof by implicit discrimination.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

We can now define a particular case of linked
lists---<i>null-terminating</i> lists and prove the specification of a
simple insertion program, which allocates a new memory cell for an
element <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and makes it to be a new head of a list pointed by
<span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span>. The allocation is performed via the primitive <span class="inlinecode"><span class="id" title="definition">allocb</span></span>, which
allocates a number of subsequent heap pointers (two in this case, as
defined by its second argument) and sets all of them to point to the
value provided.


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="HTT.lseq"><span class="id" title="definition">lseq</span></a> <span class="id" title="var">p</span> := <a class="idref" href="PnP.HTT.html#HTT.lseg"><span class="id" title="definition">lseg</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="definition">null</span>.<br/>

<br/>
<span class="id" title="keyword">Program Definition</span> <a name="HTT.insert"><span class="id" title="definition">insert</span></a> <span class="id" title="var">p</span> <span class="id" title="var">x</span> : <br/>
&nbsp;&nbsp;<span class="id" title="notation">{</span><span class="id" title="var">xs</span><span class="id" title="notation">},</span> <span class="id" title="notation">STsep</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a><span class="id" title="notation">,</span> <span class="id" title="notation">[</span><span class="id" title="notation">vfun</span> <span class="id" title="var">y</span> <span class="id" title="notation">⇒</span> <a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#y"><span class="id" title="variable">y</span></a> (<a class="idref" href="PnP.HTT.html#x"><span class="id" title="variable">x</span></a><span class="id" title="notation">::</span><a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a>)<span class="id" title="notation">]</span><span class="id" title="notation">)</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="notation">Do</span> <span class="id" title="notation">(</span><span class="id" title="var">q</span> <span class="id" title="notation">&lt;--</span> <span class="id" title="definition">allocb</span> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> 2<span class="id" title="notation">;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a> <span class="id" title="notation">::=</span> <a class="idref" href="PnP.HTT.html#x"><span class="id" title="variable">x</span></a><span class="id" title="notation">;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#q"><span class="id" title="variable">q</span></a><span class="id" title="notation">)</span>.<br/>
<span class="id" title="keyword">Next</span> <span class="id" title="keyword">Obligation</span>.<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="lemma">ghR</span>⇒<span class="id" title="var">i</span> <span class="id" title="var">xs</span> <span class="id" title="var">H</span> <span class="id" title="var">_</span>; <span class="id" title="var">heval</span>⇒<span class="id" title="var">x1</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="lemma">unitR</span> -<span class="id" title="lemma">joinA</span>; <span class="id" title="var">heval</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Next, we are going to give a specification to the list
"beheading"---removing the head element of a list. For this, we will
need a couple of auxiliary lemmas involving the list heap predicate
<span class="inlinecode"><span class="id" title="var">lseg_neq</span></span>. The first one, <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_null"><span class="id" title="lemma">lseq_null</span></a></span> is just a specialization of the
previously proved <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseg_null"><span class="id" title="lemma">lseg_null</span></a>.</span>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="HTT.lseq_null"><span class="id" title="lemma">lseq_null</span></a> <span class="id" title="var">xs</span> <span class="id" title="var">h</span> : <span class="id" title="abbreviation">valid</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">In</span> <a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <span class="id" title="definition">null</span> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="notation">[::]</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <span class="id" title="abbreviation">Unit</span>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒<span class="id" title="var">D</span>; <span class="id" title="tactic">case</span>/(<a class="idref" href="PnP.HTT.html#HTT.lseg_null"><span class="id" title="lemma">lseg_null</span></a> <span class="id" title="var">D</span>)=&gt;<span class="id" title="var">_</span> →. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The next lemma, <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_pos"><span class="id" title="lemma">lseq_pos</span></a></span>, states that if <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> is a head of a linked list,
defined by a heap <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a></span>, is not <span class="inlinecode"><span class="id" title="definition">null</span></span>, then it can be "beheaded". That
is, there will exist a head value <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>, a "next" <span class="inlinecode"><a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a></span> and a residual
heap <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a></span>, such that the heap <span class="inlinecode"><a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a></span> corresponds to the list's tail,
which is expressed by Ssreflect's <span class="inlinecode"><span class="id" title="definition">behead</span></span> function.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="HTT.lseq_pos"><span class="id" title="lemma">lseq_pos</span></a> <span class="id" title="var">xs</span> <span class="id" title="var">p</span> <span class="id" title="var">h</span> : <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">!=</span> <span class="id" title="definition">null</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">In</span> <a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">∃</span></a> <span class="id" title="var">x</span> <span class="id" title="var">r</span> <span class="id" title="var">h'</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">[/\</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">::</span> <span class="id" title="definition">behead</span> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">,</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">\+</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">.+</span> 1 <span class="id" title="notation">:-&gt;</span> <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> <span class="id" title="notation">\+</span> <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a><span class="id" title="notation">)</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">&amp;</span></a> <a class="idref" href="PnP.HTT.html#h'"><span class="id" title="variable">h'</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">In</span> <a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#r"><span class="id" title="variable">r</span></a> (<span class="id" title="definition">behead</span> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#d7e433f5d2fe56f5b712860a9ff2a681"><span class="id" title="notation">]</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">case</span>: <span class="id" title="var">xs</span>=&gt;[|<span class="id" title="var">x</span> <span class="id" title="var">xs</span>] /= <span class="id" title="var">H</span> []; <span class="id" title="tactic">first</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒<span class="id" title="var">E</span>; <span class="id" title="tactic">rewrite</span> <span class="id" title="var">E</span> <span class="id" title="lemma">eq_refl</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒<span class="id" title="var">y</span> [<span class="id" title="var">h'</span>][-&gt;] <span class="id" title="var">H1</span>; <span class="id" title="var">heval</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

We can finally define and specify the HTT procedure <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.remove"><span class="id" title="definition">remove</span></a></span>, which
removes the current head of the list and returns the pointer to its
next element or <span class="inlinecode"><span class="id" title="definition">null</span></span> if the list is empty.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Program Definition</span> <br/>
<a name="HTT.remove"><span class="id" title="definition">remove</span></a> <span class="id" title="var">p</span> : <span class="id" title="notation">{</span><span class="id" title="var">xs</span><span class="id" title="notation">},</span> <span class="id" title="notation">STsep</span> <span class="id" title="notation">(</span><a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a><span class="id" title="notation">,</span> <span class="id" title="notation">[</span><span class="id" title="notation">vfun</span> <span class="id" title="var">y</span> <span class="id" title="notation">⇒</span> <a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#y"><span class="id" title="variable">y</span></a> (<span class="id" title="definition">behead</span> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a>)<span class="id" title="notation">]</span><span class="id" title="notation">)</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="notation">Do</span> <span class="id" title="notation">(</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">if</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">==</span> <span class="id" title="definition">null</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">then</span></a> <span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">else</span></a> <span class="id" title="var">pnext</span> <span class="id" title="notation">&lt;--</span> <span class="id" title="notation">!(</span><a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">.+</span> 1<span class="id" title="notation">)</span><span class="id" title="notation">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">dealloc</span> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><span class="id" title="notation">;;</span> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">dealloc</span> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <span class="id" title="notation">.+</span> 1<span class="id" title="notation">;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#pnext"><span class="id" title="variable">pnext</span></a><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The proof is straightforward and employs both lemmas: <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_null"><span class="id" title="lemma">lseq_null</span></a></span> to
prove the "<span class="inlinecode"><span class="id" title="definition">null</span></span>" case and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_pos"><span class="id" title="lemma">lseq_pos</span></a></span> for the case when the list has
at least one element.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Next</span> <span class="id" title="keyword">Obligation</span>.<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="lemma">ghR</span>⇒<span class="id" title="var">i</span> <span class="id" title="var">xs</span> <span class="id" title="var">H</span> <span class="id" title="var">V</span>; <span class="id" title="tactic">case</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#ifP"><span class="id" title="lemma">ifP</span></a> <span class="id" title="var">H</span>⇒<span class="id" title="var">H1</span>.<br/>
- <span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> (<span class="id" title="lemma">eqP</span> <span class="id" title="var">H1</span>); <span class="id" title="tactic">case</span>/(<a class="idref" href="PnP.HTT.html#HTT.lseq_null"><span class="id" title="lemma">lseq_null</span></a> <span class="id" title="var">V</span>)=&gt;-&gt;-&gt;; <span class="id" title="var">heval</span>.<br/>
<span class="id" title="tactic">case</span>/(<a class="idref" href="PnP.HTT.html#HTT.lseq_pos"><span class="id" title="lemma">lseq_pos</span></a> (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#negbT"><span class="id" title="lemma">negbT</span></a> <span class="id" title="var">H1</span>))=&gt;<span class="id" title="var">x</span> [<span class="id" title="var">q</span>][<span class="id" title="var">h</span>][-&gt;] &lt;- /= <span class="id" title="var">H2</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="var">heval</span>; <span class="id" title="tactic">rewrite</span> 2!<span class="id" title="lemma">unitL</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


Define and verify function <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.remove_val"><span class="id" title="definition">remove_val</span></a></span> which is similar to <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.remove"><span class="id" title="definition">remove</span></a></span>,
but also returns the <i>value</i> of the last "head" of the list before
removal, in addition to the "next" pointer. Use Coq's <span class="inlinecode"><span class="id" title="var">option</span></span> type to
account for the possibility of an empty list in the result.



</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.HTT.html#HTT.LList"><span class="id" title="section">LList</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 
Define, specify and verify the imperative higher-order function
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.list_map"><span class="id" title="definition">list_map</span></a></span> that takes as arguments two types, <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>, a function <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span>
<span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a></span> and a head <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a></span> of a single-linked list, described by a
predicate <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a></span>, and changes the list in place by applying <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> to
each of its elements, while preserving the list's structure. The
specification should reflect the fact that the new "logical" contents
of the single-linked list are an <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.f"><span class="id" title="definition">f</span></a></span> map-image of the old content.

<div class="paragraph"> </div>

 The lemmas <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_null"><span class="id" title="lemma">lseq_null</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_pos"><span class="id" title="lemma">lseq_pos</span></a></span>, proved previously,
 might be useful in the proof of the established specification.

<div class="paragraph"> </div>

 A tail-recursive call can be verified via HTT's <span class="inlinecode"><span class="id" title="lemma">val_do</span></span>
 lemma, reminiscent to the rule . However, the heap it
 operates with should be "massaged" appropriately via PCM's lemmas
 <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.joinC"><span class="id" title="lemma">joinC</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.joinA"><span class="id" title="lemma">joinA</span></a></span>.

<div class="paragraph"> </div>



</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">

Let us define the following auxiliary predicates, where <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.shape_rev"><span class="id" title="definition">shape_rev</span></a></span>
splits the heap into two disjoint linked lists (by means of the
separating conjunction <span class="inlinecode">#</span>).

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="HTT.shape_rev"><span class="id" title="definition">shape_rev</span></a> <span class="id" title="var">T</span> <span class="id" title="var">p</span> <span class="id" title="var">s</span> := <span class="id" title="notation">[</span><span class="id" title="notation">Pred</span> <span class="id" title="var">h</span> <span class="id" title="notation">|</span> <a class="idref" href="PnP.HTT.html#h"><span class="id" title="variable">h</span></a> <span class="id" title="notation">\</span><span class="id" title="notation">In</span> @<a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#e0817251e7d67ad994b4d9b1aa82a412"><span class="id" title="notation">.1</span></a> <a class="idref" href="PnP.HTT.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#e0817251e7d67ad994b4d9b1aa82a412"><span class="id" title="notation">.1</span></a> <span class="id" title="notation">#</span> @<a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#675082cc4d4538da052b547bdc6ea4c9"><span class="id" title="notation">.2</span></a> <a class="idref" href="PnP.HTT.html#s"><span class="id" title="variable">s</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#675082cc4d4538da052b547bdc6ea4c9"><span class="id" title="notation">.2</span></a><span class="id" title="notation">]</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


Then the in-place list reversal is implemented by means of the
recursive function <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.reverse"><span class="id" title="definition">reverse</span></a></span> with a loop invariant expressed using the
type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.revT"><span class="id" title="definition">revT</span></a></span>.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="HTT.revT"><span class="id" title="definition">revT</span></a> <span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span> := <br/>
&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">p</span>, <span class="id" title="notation">{</span><span class="id" title="var">ps</span><span class="id" title="notation">},</span> <span class="id" title="notation">STsep</span> <span class="id" title="notation">(</span>@<a class="idref" href="PnP.HTT.html#HTT.shape_rev"><span class="id" title="definition">shape_rev</span></a> <a class="idref" href="PnP.HTT.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="PnP.HTT.html#ps"><span class="id" title="variable">ps</span></a><span class="id" title="notation">,</span> <span class="id" title="notation">[</span><span class="id" title="notation">vfun</span> <span class="id" title="var">y</span> <span class="id" title="notation">⇒</span> <a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#y"><span class="id" title="variable">y</span></a> (<span class="id" title="definition">rev</span> <a class="idref" href="PnP.HTT.html#ps"><span class="id" title="variable">ps</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#e0817251e7d67ad994b4d9b1aa82a412"><span class="id" title="notation">.1</span></a> <span class="id" title="notation">++</span> <a class="idref" href="PnP.HTT.html#ps"><span class="id" title="variable">ps</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#675082cc4d4538da052b547bdc6ea4c9"><span class="id" title="notation">.2</span></a>)<span class="id" title="notation">]</span><span class="id" title="notation">)</span>.<br/>

<br/>
<span class="id" title="keyword">Program Definition</span> <br/>
<a name="HTT.reverse"><span class="id" title="definition">reverse</span></a> <span class="id" title="var">T</span> <span class="id" title="var">p</span> : <span class="id" title="notation">{</span><span class="id" title="var">xs</span><span class="id" title="notation">},</span> <span class="id" title="notation">STsep</span> <span class="id" title="notation">(</span>@<a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a><span class="id" title="notation">,</span> <span class="id" title="notation">[</span><span class="id" title="notation">vfun</span> <span class="id" title="var">y</span> <span class="id" title="notation">⇒</span> <a class="idref" href="PnP.HTT.html#HTT.lseq"><span class="id" title="definition">lseq</span></a> <a class="idref" href="PnP.HTT.html#y"><span class="id" title="variable">y</span></a> (<span class="id" title="definition">rev</span> <a class="idref" href="PnP.HTT.html#xs"><span class="id" title="variable">xs</span></a>)<span class="id" title="notation">]</span><span class="id" title="notation">)</span> :=<br/>
&nbsp;&nbsp;<span class="id" title="notation">Do</span> <span class="id" title="notation">(</span><span class="id" title="keyword">let</span>: <span class="id" title="var">reverse</span> := <span class="id" title="definition">Fix</span> (<span class="id" title="keyword">fun</span> (<span class="id" title="var">reverse</span> : <a class="idref" href="PnP.HTT.html#HTT.revT"><span class="id" title="definition">revT</span></a> <a class="idref" href="PnP.HTT.html#T"><span class="id" title="variable">T</span></a>) <span class="id" title="var">p</span> ⇒ <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="notation">Do</span> <span class="id" title="notation">(</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">if</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#e0817251e7d67ad994b4d9b1aa82a412"><span class="id" title="notation">.1</span></a> <span class="id" title="notation">==</span> <span class="id" title="definition">null</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">then</span></a> <span class="id" title="definition">ret</span> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#675082cc4d4538da052b547bdc6ea4c9"><span class="id" title="notation">.2</span></a> <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssreflect.html#00a1a5b58aac8f1e3f1abff064a39f9d"><span class="id" title="notation">else</span></a> <span class="id" title="var">xnext</span> <span class="id" title="notation">&lt;--</span> <span class="id" title="notation">!</span><a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#e0817251e7d67ad994b4d9b1aa82a412"><span class="id" title="notation">.1</span></a> <span class="id" title="notation">.+</span> 1<span class="id" title="notation">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#e0817251e7d67ad994b4d9b1aa82a412"><span class="id" title="notation">.1</span></a> <span class="id" title="notation">.+</span> 1 <span class="id" title="notation">::=</span> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#675082cc4d4538da052b547bdc6ea4c9"><span class="id" title="notation">.2</span></a><span class="id" title="notation">;;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#reverse"><span class="id" title="variable">reverse</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.HTT.html#xnext"><span class="id" title="variable">xnext</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#e0817251e7d67ad994b4d9b1aa82a412"><span class="id" title="notation">.1</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><span class="id" title="notation">)</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">in</span> <span class="id" title="var">reverse</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.HTT.html#p"><span class="id" title="variable">p</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">,</span></a> <span class="id" title="definition">null</span><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#e6756e10c36f149b18b4a8741ed83079"><span class="id" title="notation">)</span></a><span class="id" title="notation">)</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>


We invite the reader to conduct the verification of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.reverse"><span class="id" title="definition">reverse</span></a></span>, proving
that it satisfies the given specification.

<div class="paragraph"> </div>

 It might be a good idea to make use of the previously proved
 lemmas <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_null"><span class="id" title="lemma">lseq_null</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.lseq_pos"><span class="id" title="lemma">lseq_pos</span></a></span>.

<div class="paragraph"> </div>

 Be careful with the logical values of variables passed to the
<span class="inlinecode"><span class="id" title="lemma">gh_ex</span></span> lemma before verifying a recursive call of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.reverse"><span class="id" title="definition">reverse</span></a></span>.

<div class="paragraph"> </div>

 A verification goal to a function defined via <span class="inlinecode"><span class="id" title="keyword">Fix</span></span> can be
reduced via the <span class="inlinecode"><span class="id" title="lemma">val_doR</span></span> lemma or similar ones.

<div class="paragraph"> </div>

 The <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.shape_rev"><span class="id" title="definition">shape_rev</span></a></span> predicate is in fact an existential in
disguise: it can be proved by providing appropriate witnesses.

<div class="paragraph"> </div>

 Rewriting <span class="inlinecode"><span class="id" title="lemma">rev_cons</span></span>, <span class="inlinecode"><span class="id" title="lemma">cat_rcons</span></span> and <span class="inlinecode"><span class="id" title="lemma">cats0</span></span> from the <span class="inlinecode"><span class="id" title="library">seq</span></span>
library will be useful for establishing equalities between lists.

</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
<script src="https://jscoq.github.io/node_modules/jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
<script src="../js/jscoq-embed.js" type="text/javascript"></script>
</html>
