<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../js/clean.css" rel="stylesheet" type="text/css" />
<title>PnP.LogicPrimer</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library PnP.LogicPrimer</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">
 
<div class="paragraph"> </div>


<div class="paragraph"> </div>

In the previous chapter we had an opportunity to explore Coq as a
functional programming language and learn how to define inductive
datatypes and programs that operate with them, implementing the latter
ones directly or using the automatically-generated recursion
combinators. Importantly, most of the values that we met until this
moment, inhabited the types, which were defined as elements of the
sort <span class="inlinecode"><span class="id" title="keyword">Set</span></span>. The types <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span>, <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#empty"><span class="id" title="inductive">empty</span></a></span>, <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span> etc. are
good examples of <i>first-order</i> types inhabiting the sort <span class="inlinecode"><span class="id" title="keyword">Set</span></span> and,
therefore, contributing to the analogy between sets and first-order
types, which we explored previously.  In this chapter, we will be
working with a new kind of entities, incorporated by Coq:
<i>propositions</i>.

<div class="paragraph"> </div>

<a name="lab20"></a><h1 class="section">Propositions and the <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> sort</h1>



<div class="paragraph"> </div>

In Coq, propositions bear a lot of similarities with types,
demonstrated in Chapter, and inhabit a separate
sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, similarly to how first-order types inhabit
<span class="inlinecode"><span class="id" title="keyword">Set</span></span>. <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>  The "values" that have
elements of <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> as their types are usually referred to as <i>proofs</i>
or <i>proof terms</i>, the naming convention which stems out of the idea of
 .
Sometimes, the Curry-Howard Correspondence is paraphrased as
<i>proofs-as-programs</i>, which is truly illuminating when it comes to the
intuition behind the formal proof construction in Coq, which, in fact,
is just programming in disguise.

<div class="paragraph"> </div>







<div class="paragraph"> </div>

The <i>Calculus of Inductive Constructions</i>
(CIC) a logical
foundation of Coq, similarly to its close relative, Martin-'s
<i>Intuitionistic Type Theory</i> , considers proofs
to be just regular values of the "programming" language it
defines. Therefore, the process of constructing proofs in Coq is
very similar to the process of writing programs. Intuitively, when
one asks a question "Whether the proposition <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is <i>true</i>?", what is
meant in fact is "Whether the <i>proof</i> of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> can be
constructed?". This is an unusual twist, which is crucial for
understanding the concept of the "truth" and proving propositions in
CIC (and, equivalently, in Coq), so we specifically outline it here in
the form of a motto:

<div class="paragraph"> </div>



<div class="paragraph"> </div>

This formulation of "truth" is somewhat surprising at the first
encounter, comparing to classical propositional logic, where the
propositions are considered to be true simply if they are tautologies
(i.e., reduce to the boolean value <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span> for all possible
combinations of their free variables' values), therefore leading to
the common proof method in classical propositional logic: truth
tables.  While the truth table methodology immediately delivers the
recipe to prove propositions without quantifiers <i>automatically</i> (that
is, just by checking the corresponding truth tables), it does not
quite scale when it comes to the higher-order propositions (i.e.,
quantifying over predicates) as well as of propositions quantifying
over elements of arbitrary domains. For instance, the following
proposition, in which the reader can recognize the induction principle
over natural numbers, cannot be formulated in the zeroth- or
first-order propositional logic (and, in fact, in <i>any</i> propositional
logic):

<div class="paragraph"> </div>



<div class="paragraph"> </div>

The statement above is <i>second-order</i> as it binds a first-order
predicate by means of universal quantification, which makes it belong
to the corresponding second-order logic (which is not even
propositional, as it quantifies over arbitrary natural values, not
just propositions). Higher-order logics are
known to be undecidable in general, and, therefore, there is no
automatic way to reduce an arbitrary second-order formula to one of
the two values: <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span> or <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a></span>.

<div class="paragraph"> </div>

CIC as a logic is expressive enough to accommodate propositions with
quantifications of an arbitrary order and over arbitrary values. On
one hand, it makes it an extremely powerful tool to state almost any
proposition of interest in modern mathematics or computer science. On
the other hand, proving such statements (i.e., constructing their
proof terms), will require human assistance, in the same way the
"paper-and-pencil" proofs are constructed in classical
mathematics. However, unlike the paper-and-pencil proofs, proofs
constructed in Coq are a subject of immediate <i>automated</i> check, since
they are just programs to be verified for well-typedness. Therefore,
the process of proof construction in Coq is <i>interactive</i> and assumes
the constant interoperation between a human prover, who constructs a
proof term for a proposition (i.e., writes a program), and Coq, the
proof assistant, which carries out the task of <i>verifying</i> the proof
(i.e., type-checking the program). This largely defines our agenda for
the rest of this course: we are going to see how to <i>prove</i> logical
statements by means of writing <i>programs</i>, that have the types
corresponding to these statements.

<div class="paragraph"> </div>

In the rest of this chapter we will focus only on the capability of
Coq as a formal system allowing one to reason about propositions,
leaving reasoning about values aside till the next chapter. It is
worth noticing that a fragment of Coq, which deals with the sort
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span>, accommodating all the propositions, and allows the programmer
to make statements with propositions, corresponds to the logical
calculus, known as 
(see Chapter 30 of) 
extending , mentioned in
Chapter. Unlike , which introduces
polymorphic types, and, equivalently, first-order propositions that
quantify over other propositions,  allows one to
quantify as well over <i>type operators</i>, which can be also thought of
as higher-order propositions.

<div class="paragraph"> </div>

<a name="lab21"></a><h1 class="section">The truth and the falsehood in Coq</h1>


<div class="paragraph"> </div>

We start our acquaintance with propositional logic in Coq by
demonstrating how the two simplest propositions, the truth and the
falsehood, are encoded. Once again, let us remember that, unlike in
propositional logic, in Coq these two are <i>not</i> the only possible
propositional <i>values</i>, and soon we will see how a wide range of
propositions different from mere truth or falsehood are
implemented. From now on, we will be always including to the
development the standard Ssreflect's module <span class="inlinecode"><span class="id" title="library">ssreflect</span></span>,
 which imports some necessary machinery for dealing
with propositions and proofs.

<div class="paragraph"> </div>

 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">mathcomp</span> <span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">ssreflect</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The truth is represented in Coq as a datatype of sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> with just
one constructor, taking no arguments:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> : <span class="id" title="keyword">Prop</span> :=  <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>



<div class="paragraph"> </div>

Such simplicity makes it trivial to construct an instance of the
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> proposition:
Now we can prove the following proposition in Coq's embedded
propositional logic, essentially meaning that <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> is provable.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LogicPrimer.true_is_true"><span class="id" title="lemma">true_is_true</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">1 <span class="id" title="keyword">subgoals</span>, <span class="id" title="keyword">subgoal</span> 1 (<span class="id" title="var">ID</span> 1)<br/>
&nbsp;&nbsp;<br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The command <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span>  serves two purposes. First, similarly to the
command <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>, it defines a named entity, which is not
necessarily a proposition. In this case the name is
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.true_is_true"><span class="id" title="lemma">true_is_true</span></a></span>. Next, similarly to <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>, there might follow a
list of parameters, which is empty in this example. Finally, after the
colon <span class="inlinecode">:</span> there is a type of the defined value, which in this case it
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span>. With this respect there is no difference between <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> and
<span class="inlinecode"><span class="id" title="keyword">Definition</span></span>. However, unlike <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>, <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> doesn't require
one to provide the expression of the corresponding type right
away. Instead, the <i>interactive proof mode</i>   
is activated, so the proof term could be constructed
incrementally. The process of the gradual proof construction is what
makes Coq to be a <i>interactive proof assistant</i>, in addition to being
already a programming language with dependent types.

<div class="paragraph"> </div>

Although not necessary, it is considered a good programming practice
in Coq to start any interactive proof with the Coq's command
 <span class="inlinecode"><span class="id" title="keyword">Proof</span></span>, which makes the final scripts easier to read
and improves the general proof layout.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 In the interactive proof mode, the <span class="inlinecode"><span class="id" title="var">goals</span></span> display
shows a <i>goal</i> of the proof---the type of the value to be constructed
(<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> in this case), which is located below the double line. Above
the line one can usually see the context of <i>assumptions</i>, which can
be used in the  process of constructing the
proof. Currently, the assumption context is empty, as the theorem we
stated does not make any and ventures to prove <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> out of thin
air. Fortunately, this is quite easy to do, as from the formulation of
the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> type we already know that it is inhabited by its only
constructor <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a></span>. The next line proved the <i>exact</i> value of the type of
the goal.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">exact</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

This completes the proof, as indicated by the Proof General's
 display:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">No</span> <span class="id" title="var">more</span> <span class="id" title="keyword">subgoals</span>.<br/>
(<span class="id" title="tactic">dependent</span> <span class="id" title="var">evars</span>:)
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The only thing left to complete the proof is to inform Coq that now
the theorem <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.true_is_true"><span class="id" title="lemma">true_is_true</span></a></span> is proved, which is achieved by typing the
command  <span class="inlinecode"><span class="id" title="keyword">Qed</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

In fact, typing <span class="inlinecode"><span class="id" title="keyword">Qed</span></span> invokes a series of additional checks, which
ensure the well-formedness of the constructed proof term. Although the
proof of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.true_is_true"><span class="id" title="lemma">true_is_true</span></a></span> is obviously valid, in general, there is a
number of proof term properties to be checked <i>a posteriori</i> and
particularly essential in the case of proofs about infinite objects,
which we do not cover in these course (see 
of for a detailed discussion on such
proofs).

<div class="paragraph"> </div>

So, our first theorem is proved. As it was hinted previously, it could
have been stated even more concisely, formulated as a mere definition,
and proved by means of providing a corresponding value, without the
need to enter the proof mode:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.true_is_true'"><span class="id" title="definition">true_is_true'</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a> := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Although this is a valid way to prove statements in Coq, it is not as
convenient as the interactive proof mode, when it comes to
construction of large proofs, arising from complicated
statements. This is why, when it comes to proving propositions, we
will prefer the interactive proof mode to the "vanilla" program
definition. It is worth noticing, though, that even though the process
of proof construction in Coq usually looks more like writing a
<i>script</i>, consisting from a number of commands (which are called
<i>tactics</i> in Coq jargon),  the result of such script, given that it eliminates all of
the goals, is a valid well-typed Coq program. In comparison, in some
other dependently-typed frameworks (e.g., in Agda), the
construction of proof terms does not obscure the fact that what is
being constructed is a program, so the resulting interactive proof
process is formulated as "filling the holes" in a program (i.e., a
proof-term), which is being gradually refined. We step away from the
discussion on which of these two views to the proof term construction
is more appropriate.

<div class="paragraph"> </div>

There is one more important difference between values defined as
<span class="inlinecode"><span class="id" title="keyword">Definition</span></span>s  and <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span>s. While
both define what in fact is a proof terms for the declared type, the
value bound by <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> is <i>transparent</i>: it can be executed by
means of unfolding and subsequent evaluation of its body. In contrast,
a proof term bound by means of <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span> is <i>opaque</i>, which means that
its body cannot be evaluated and serves only one purpose: establish
the fact that the corresponding type (the theorem's statement) is
inhabited, and, therefore is true.  This distinction between
definitions and theorems arises from the notion of <i>proof
irrelevance</i>, which, informally, states that (ideally) one shouldn't
be able to distinguish between two proofs of the same statement as
long as they both are valid. Conversely, the programs
(that is, what is created using the <span class="inlinecode"><span class="id" title="keyword">Definition</span></span> command) are
typically of interest by themselves, not only because of the type they
return.

<div class="paragraph"> </div>

The difference between the two definitions of the truth's validity,
which we have just constructed, can be demonstrated by means of the
<span class="inlinecode"><span class="id" title="keyword">Eval</span></span> command.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.true_is_true"><span class="id" title="lemma">true_is_true</span></a>.<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.true_is_true"><span class="id" title="lemma">true_is_true</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Eval</span> <span class="id" title="tactic">compute</span> <span class="id" title="tactic">in</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.true_is_true'"><span class="id" title="definition">true_is_true'</span></a>.<br/>
</div>

<div class="doc">
<span class="inlinecode"></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span>

<div class="paragraph"> </div>

As we can see now, the theorem is evaluated to itself, whereas the
definition evaluates to it body, i.e., the value of the constructor
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#I"><span class="id" title="constructor">I</span></a></span>.  

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

A more practical analogy for the above distinction can be drawn if one
will think of <span class="inlinecode"><span class="id" title="keyword">Definition</span></span>s as of mere functions, packaged into
libraries and intended to be used by third-party clients. In the same
spirit, one can think of <span class="inlinecode"><span class="id" title="keyword">Theorem</span></span>s as of facts that need to be
checked only once when established, so no one would bother to re-prove
them again, knowing that they are valid, and just appeal to their
types (statement) without exploring the proof. This is similar to what is happening during the oral
examinations on mathematical disciplines: a student is supposed to
remember the statements of theorems from the <i>previous</i> courses and
semesters, but is not expected to reproduce their proofs.

<div class="paragraph"> </div>

At this point, an attentive reader can notice that the definition of
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#True"><span class="id" title="inductive">True</span></a></span> in Coq is strikingly similar to the definition of the type
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span> from . This is a fair observation,
which brings us again to the Curry-Howard analogy, and makes it
possible to claim that the trivial truth proposition is isomorphic to
the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span> type from functional programming. Indeed, both have just
one way to be constructed and can be constructed in any context, as
their single constructor does not require any arguments.

<div class="paragraph"> </div>

Thinking by analogy, one can now guess how the falsehood can be encoded.

<div class="paragraph"> </div>



</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> : <span class="id" title="keyword">Prop</span> :=  
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Unsurprisingly, the proposition <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> in Coq is just a Curry-Howard
counterpart of the type <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#empty"><span class="id" title="inductive">empty</span></a></span>, which we have constructed in
. Moreover, the same intuition that was
applicable to <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#empty"><span class="id" title="inductive">empty</span></a></span>'s recursion principle ("anything can be produced
given an element of an empty set"), is applicable to reasoning by
induction with the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> proposition:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

That is, <i>any</i> proposition can be derived from the falsehood by means
of implication. For instance, we can
prove now that <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> implies the equality <span class="inlinecode">1</span> <span class="inlinecode">=</span> <span class="inlinecode">2</span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LogicPrimer.one_eq_two"><span class="id" title="lemma">one_eq_two</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> 1 <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 2.<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

One way to prove this statement is to use the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> induction
principle, i.e., the theorem <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span>, directly by instantiating it
with the right predicate <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">exact</span>: (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a> (1 <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> 2)).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

This indeed proves the theorem, but for now, let us explore a couple
of other ways to prove the same statement. For this we first
 <span class="inlinecode"><span class="id" title="keyword">Undo</span></span> the last command of the already succeeded but not
yet completed proof.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Undo</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Instead of supplying the argument <span class="inlinecode">(1</span> <span class="inlinecode">=</span> <span class="inlinecode">2)</span> to <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span> manually,
we can leave it to Coq to figure out, what it should be, by using the
Ssreflect <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> tactic.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The following thing just happened: the tactic <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> supplied with
an argument <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span>, tried to figure out whether our goal <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>
<span class="inlinecode">→</span> <span class="inlinecode">(1</span> <span class="inlinecode">=</span> <span class="inlinecode">2)</span> matches any <i>head</i> type of the theorem <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span>.
 By <i>head type</i> we mean a component of type (in
this case, <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>), which is a type by itself
and possibly contains free variables. For instance, recalling that
<span class="inlinecode">→</span> is right-associative, head-types of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span> would be <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>,
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> itself.

<div class="paragraph"> </div>

So, in our example, the call to the tactics <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span> makes
Coq realize that the goal we are trying to prove matches the type
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, where <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is taken to be <span class="inlinecode">(1</span> <span class="inlinecode">=</span> <span class="inlinecode">2)</span>. Since in this case
there is no restrictions on what <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> can be (as it is
universally-quantified in the type of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span>), Coq assigns <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> to
be <span class="inlinecode">(1</span> <span class="inlinecode">=</span> <span class="inlinecode">2)</span>, which, after such specialization, turns the type of
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span> to be exactly the goal we're after, and the proof is done.

<div class="paragraph"> </div>

There are many more ways to prove this rather trivial statement, but
at this moment we will demonstrate just yet another one, which does
not appeal to the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False_ind"><span class="id" title="definition">False_ind</span></a></span> induction principle, but instead
proceeds by <i>case analysis</i>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Undo</span>.<br/>

<br/>
<span class="id" title="tactic">case</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The tactic <span class="inlinecode"><span class="id" title="tactic">case</span></span> makes Coq to perform the case
analysis. In particular, it <i>deconstructs</i> the <i>top assumption</i> of the
goal. The top assumption in the goal is such that it comes first
before any arrows, and in this case it is a value of type
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>. Then, for all constructors of the type, whose value is being
case-analysed, the tactic <span class="inlinecode"><span class="id" title="tactic">case</span></span> constructs <i>subgoals</i> to be
proved. Informally, in mathematical reasoning, the invocation of the
<span class="inlinecode"><span class="id" title="tactic">case</span></span> tactic would correspond to the statement "let us consider all
possible cases, which amount to the construction of the top
assumption". Naturally, since <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span> has <i>no</i> constructors (as it
corresponds to the <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#empty"><span class="id" title="inductive">empty</span></a></span> type), the case analysis on it produces
<i>zero</i> subgoals, which completes the proof immediately. Since the
result of the proof is just some program, again, we can demonstrate
the effect of <span class="inlinecode"><span class="id" title="tactic">case</span></span> tactic by proving the same theorem with an exact
proof term:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Undo</span>.<br/>

<br/>
<span class="id" title="tactic">exact</span>: (<span class="id" title="keyword">fun</span> (<span class="id" title="var">f</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>) ⇒ <span class="id" title="keyword">match</span> <a class="idref" href="PnP.LogicPrimer.html#f"><span class="id" title="variable">f</span></a> <span class="id" title="keyword">with</span> <span class="id" title="keyword">end</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

As we can see, one valid proof term of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.one_eq_two"><span class="id" title="lemma">one_eq_two</span></a></span> is just a
function, which case-analyses on the value of type <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>, and such
case-analysis has no branches.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab22"></a><h1 class="section">Implication and universal quantification</h1>


<div class="paragraph"> </div>

By this moment we have already seen how implication is represented in
Coq: it is just a functional type, represented by the "arrow" notation
<span class="inlinecode">→</span> and familiar to all functional programmers. Indeed, if a function
of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> is a program that takes an argument value of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>
and returns a result value of type <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>, then the propositional
implication <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> is, ... a program that takes an argument proof
term of type <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and returns a proof of the proposition <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>.

<div class="paragraph"> </div>

Unlike most of the value-level functions we have seen so far,
propositions are usually parametrized by other propositions, which
makes them instances of <i>polymorphic</i> types, as they appear in

 and . Similarly to these systems, in
Coq the universal quantifier <span class="inlinecode"><span class="id" title="keyword">∀</span></span> (spelled <tt>forall</tt>) binds a
variable immediately following it in the scope of the subsequent
type. For
instance, the transitivity of implication in Coq can be expressed via
the following proposition:

<div class="paragraph"> </div>


<span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>:</span> <span class="inlinecode"><span class="id" title="keyword">Prop</span>,</span> <span class="inlinecode">(<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a>)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>


<div class="paragraph"> </div>

The proposition is therefore <i>parametrized</i> over three propositional
variables, <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>, and states that from a proof term of
type <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> and a proof term of type <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> one can build a
proof term of type <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>. Let us now prove this statement in the form of
a theorem.  
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a>: <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>: <span class="id" title="keyword">Prop</span>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#R"><span class="id" title="variable">R</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Our goal is the statement of the theorem, its type. The first thing we
are going to do is to "peel off" some of the goal assumptions---the
<span class="inlinecode"><span class="id" title="keyword">∀</span></span>-bound variables---and move them from the goal to the
assumption context (i.e., from below to above the double line). This
step in the proof script is usually referred to as <i>bookkeeping</i>,
since it does not directly contribute to reducing the goal, but
instead moves some of the values from the goal to assumption, as a
preparatory step for the future reasoning.

<div class="paragraph"> </div>




Ssreflect offers a tactic and a small but powerful toolkit of
<i>tacticals</i> (i.e., higher-order tactics) for bookkeeping. In
particular, for moving the bound variables from "bottom to the top",
one should use a combination of the "no-op" tactic <span class="inlinecode"><span class="id" title="tactic">move</span></span>
and the tactical <span class="inlinecode">⇒</span> (spelled <tt>=</tt>&gt;). The following
command moves the next three assumptions from the goal, <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> and
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> to the assumption context, simultaneously renaming them to <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>,
<span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> and <span class="inlinecode"><span class="id" title="var">C</span></span>. The renaming is optional, so we just show it here to
demonstrate the possibility to give arbitrary (and, preferably, more
meaningful) names to the assumption variables "on the fly" while
constructing the proof via a script.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">A</span> <span class="id" title="var">B</span> <span class="id" title="var">C</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<span class="id" title="var">C</span> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;(<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>) → (<a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> → <span class="id" title="var">C</span>) → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <span class="id" title="var">C</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We can now move the three other arguments to the top using the same
command: the <span class="inlinecode"><span class="id" title="tactic">move</span>⇒</span> combination works uniformly for <span class="inlinecode"><span class="id" title="keyword">∀</span></span>-bound
variables as well as for the propositions on the left of the arrow.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">H1</span> <span class="id" title="var">H2</span> <span class="id" title="var">a</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">H1</span> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">H2</span> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> → <span class="id" title="var">C</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="var">C</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Again, there are multiple ways to proceed now. For example, we can
recall the functional programming and get the result of type <span class="inlinecode"><span class="id" title="var">C</span></span> just
by two subsequent applications of <span class="inlinecode"><span class="id" title="var">H1</span></span> and <span class="inlinecode"><span class="id" title="var">H2</span></span> to the value <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">exact</span>: (<span class="id" title="var">H2</span> (<span class="id" title="var">H1</span> <span class="id" title="var">a</span>)).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Alternatively, we can replace the direct application of the hypotheses
<span class="inlinecode"><span class="id" title="var">H1</span></span> and <span class="inlinecode"><span class="id" title="var">H2</span></span> by the reversed sequence of calls to the <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span>
tactics.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Undo</span>.<br/>

<br/>
</div>

<div class="doc">

The first use of <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> will replace the goal <span class="inlinecode"><span class="id" title="var">C</span></span> by the goal <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>,
since this is what it takes to get <span class="inlinecode"><span class="id" title="var">C</span></span> by using <span class="inlinecode"><span class="id" title="var">H2</span></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="var">H2</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">H1</span> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>
<div class="paragraph"> </div>

</span>
The second use of <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> reduces the proof of <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> to the proof of
<span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>, demanding an appropriate argument for <span class="inlinecode"><span class="id" title="var">H1</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="var">H1</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Notice that both calls to <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> removed the appropriate hypotheses,
<span class="inlinecode"><span class="id" title="var">H1</span></span> and <span class="inlinecode"><span class="id" title="var">H2</span></span> from the assumption context. If one needs a hypothesis
to stay in the context (to use it twice, for example), then the
occurrence of the tactic argument hypothesis should be parenthesised:
<span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> <span class="inlinecode">(<span class="id" title="var">H1</span>)</span>.

<div class="paragraph"> </div>

Finally, we can see that the only goal left to prove is to provide a
proof term of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>. Luckily, this is exactly what we have in the
assumption by the name <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span>, so the following demonstration of the
exact <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> finishes the proof:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">exact</span>: <span class="id" title="var">a</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

In the future, we will replace the use of trivial tactics, such as
<span class="inlinecode"><span class="id" title="tactic">exact</span>:</span> by Ssreflect's much more powerful tactics <span class="inlinecode"><span class="id" title="var">done</span></span>, which
combines a number of standard Coq's tactics in an attempt to finish
the proof of the current goal and reports an error if it fails to do
so. 

<div class="paragraph"> </div>



</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab23"></a><h2 class="section">On forward and backward reasoning</h2>


<div class="paragraph"> </div>

Let us check now the actual value of the proof term of theorem
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a></span>. 

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a> = <br/>
&nbsp;&nbsp;<span class="id" title="keyword">fun</span> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> <span class="id" title="var">C</span> : <span class="id" title="keyword">Prop</span>) (<span class="id" title="var">H1</span> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>) (<span class="id" title="var">H2</span> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> → <span class="id" title="var">C</span>) (<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>) ⇒<br/>
&nbsp;&nbsp;(<span class="id" title="keyword">fun</span> <span class="id" title="var">_evar_0_</span> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> ⇒ <span class="id" title="var">H2</span> <span class="id" title="var">_evar_0_</span>) ((<span class="id" title="keyword">fun</span> <span class="id" title="var">_evar_0_</span> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> ⇒ <span class="id" title="var">H1</span> <span class="id" title="var">_evar_0_</span>) <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> : <span class="id" title="keyword">Prop</span>, (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a>) → (<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>) → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a><br/>
<br/>
<span class="id" title="var">Argument</span> <span class="id" title="var">scopes</span> <span class="id" title="var">are</span> [<span class="id" title="var">type_scope</span> <span class="id" title="var">type_scope</span> <span class="id" title="var">type_scope</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>]
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Even though the proof term looks somewhat hairy, this is almost
exactly our initial proof term from the first proof attempt: <span class="inlinecode"><span class="id" title="var">H2</span></span> <span class="inlinecode">(<span class="id" title="var">H1</span></span>
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a>)</span>. The only difference is that the hypotheses <span class="inlinecode"><span class="id" title="var">H1</span></span> and <span class="inlinecode"><span class="id" title="var">H2</span></span> are
<i>eta-expanded</i>, that is instead of simply <span class="inlinecode"><span class="id" title="var">H1</span></span>
the proof terms features its operational equivalent <span class="inlinecode"><span class="id" title="keyword">fun</span></span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a>:</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> <span class="inlinecode">⇒</span> <span class="inlinecode"><span class="id" title="var">H2</span></span>
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a></span>. Otherwise, the printed program term indicates that the proof
obtained by means of direct application of <span class="inlinecode"><span class="id" title="var">H1</span></span> and <span class="inlinecode"><span class="id" title="var">H2</span></span> is the same
(modulo eta-expansion) as the proof obtained by means of using the
<span class="inlinecode"><span class="id" title="tactic">apply</span>:</span> tactic.

<div class="paragraph"> </div>

These two styles of proving: by providing a direct proof to the goal
or some part of it, and by first reducing the goal via tactics, are
usually referred in the mechanized proof community as <i>forward</i> and
<i>backward</i> proof styles.

<div class="paragraph"> </div>

<ul class="doclist">
<li> The <i>backward</i> proof style assumes that the goal is being gradually
  transformed by means of applying some tactics, until its proof
  becomes trivial and can be completed by means of basic tactics,
  like <span class="inlinecode"><span class="id" title="tactic">exact</span>:</span> or <span class="inlinecode"><span class="id" title="var">done</span></span>.

<div class="paragraph"> </div>


</li>
<li> The <i>forward</i> proof style assumes that the human prover has some
  "foresight" with respect to the goal she is going to prove, so she
  can define some "helper" entities as well as to adapt the available
  assumptions, which will then be used to solve the goal. Typical
  example of the forward proofs are the proofs from the classical
  mathematic textbooks: first a number of "supporting" lemmas is
  formulated, proving some partial results, and finally all these
  lemmas are applied in concert in order to prove an important
  theorem.

</li>
</ul>

<div class="paragraph"> </div>

While the standard Coq is very well supplied with a large number of
tactics that support reasoning in the backward style, it is less
convenient for the forward-style reasoning. This aspect of the tool is
significantly enhanced by Ssreflect, which introduces a small number
of helping tactics, drastically simplifying the forward proofs, as we
will see in the subsequent chapters.

<div class="paragraph"> </div>

<a name="lab24"></a><h2 class="section">Refining and bookkeeping assumptions</h2>


<div class="paragraph"> </div>

Suppose, we have the following theorem to prove, which is just a
simple reformulation of the previously proved <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a></span>:

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LogicPrimer.imp_trans'"><span class="id" title="lemma">imp_trans'</span></a> (<span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>: <span class="id" title="keyword">Prop</span>) : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#R"><span class="id" title="variable">R</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#R"><span class="id" title="variable">R</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">H1</span> <span class="id" title="var">H2</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Notice that we made the propositional variables <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> to be
parameters of the theorem, rather than <span class="inlinecode"><span class="id" title="keyword">∀</span></span>-quantified
values. This relieved us from the necessity to lift them using
<span class="inlinecode"><span class="id" title="tactic">move</span>⇒</span> in the beginning of the proof.

<div class="paragraph"> </div>

In is natural to expect that the original <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a></span> will be of some
use. We are now in the position to apply it directly, as the current
goal matches its conclusion. However, let us do something slightly
different: <i>move</i> the statement of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a></span> into the goal,
simultaneously with specifying it (or, equivalently, partially
applying) to the assumptions <span class="inlinecode"><span class="id" title="var">H1</span></span> and <span class="inlinecode"><span class="id" title="var">H2</span></span>. Such move "to the bottom
part" in Ssreflect is implemented by means of the  <span class="inlinecode">:</span>
tactical, following the <span class="inlinecode"><span class="id" title="tactic">move</span></span> command:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span>: (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>)=&gt; <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">H1</span> : <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">H2</span> : <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a> : (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a>) → (<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>) → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

What has happened now is a good example of the forward reasoning: the
specialized version of <span class="inlinecode">(<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>)</span>, namely, <span class="inlinecode">(<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a>)</span> <span class="inlinecode">→</span> <span class="inlinecode">(<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode">→</span>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>, has been moved to the goal, so it became <span class="inlinecode">((<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a>)</span> <span class="inlinecode">→</span>
<span class="inlinecode">(<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>. Immediately after that, the top
assumption (that is, what has been just "pushed" to the goal stack)
was moved to the top and given the name <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span>. Now we have the
assumption <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> that can be applied in order to reduce the goal.  

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<span class="id" title="var">H1</span> : <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">H2</span> : <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a><br/>
<br/>
<span class="id" title="keyword">subgoal</span> 2 (<span class="id" title="var">ID</span> 142) <span class="id" title="keyword">is</span>:<br/>
&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The proof forked into two goals, since <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> had two arguments, which we
can now fulfill separately, as they trivially are our assumptions.  

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="var">done</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The proof is complete, although the last step is somewhat repetitive,
since we know that for two generated sub-goals the proofs are the
same. In fact, applications of tactics can be <i>chained</i> using the <span class="inlinecode">;</span>
connective, so the following complete proof of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans'"><span class="id" title="lemma">imp_trans'</span></a></span>
runs <span class="inlinecode"><span class="id" title="var">done</span></span> for <i>all</i> subgoals generated by <span class="inlinecode"><span class="id" title="tactic">apply</span>:</span>
<span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span>:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Restart</span>.<br/>

<br/>
<span class="id" title="tactic">move</span>: (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>)=&gt; <span class="id" title="var">H</span> <span class="id" title="var">H1</span> <span class="id" title="var">H2</span>.<br/>
<span class="id" title="tactic">apply</span>: <span class="id" title="var">H</span>; <span class="id" title="var">done</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Also, notice that the sequence in which the hypotheses were moved to
the top has changed: in order to make the proof more concise, we first
created the "massaged" version of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a></span>, and then moved it as
<span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> to the top, following by <span class="inlinecode"><span class="id" title="var">H1</span></span> and <span class="inlinecode"><span class="id" title="var">H2</span></span>, which were in the goal
from the very beginning.

<div class="paragraph"> </div>

To conclude this section, let us demonstrate even shorter way to prove
this theorem once again.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Restart</span>.<br/>
<span class="id" title="tactic">move</span>⇒<span class="id" title="var">H1</span> <span class="id" title="var">H2</span>; <span class="id" title="tactic">apply</span>: (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a> <span class="id" title="var">P</span> <span class="id" title="var">Q</span> <span class="id" title="var">R</span>)=&gt;//.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

After traditional move of the two hypotheses to the top, we applied
the specialised version of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.imp_trans"><span class="id" title="lemma">imp_trans</span></a></span>, where its three first
arguments were explicitly instantiated with the local <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> and
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>. This application generated two subgoals, each of which has been
then automatically solved by the trailing tactical <span class="inlinecode">⇒</span>
<span class="inlinecode">//</span>, which is equivalent to <span class="inlinecode">;<span class="id" title="tactic">try</span></span> <span class="inlinecode"><span class="id" title="var">done</span></span> and, informally speaking,
"tries to kill all the newly created goals".

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab25"></a><h1 class="section">Conjunction and disjunction</h1>



<div class="paragraph"> </div>

Two main logical connectives, conjunction and disjunction, are
implemented in Coq as simple inductive predicates in the sort
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. In order to avoid some clutter, from this moment and till the
end of the chapter let us start a new module <span class="inlinecode"><span class="id" title="var">Connectives</span></span> and assume
a number of propositional variables in it (as we remember, those will
be abstracted over outside of the module in the statements
they happen to occur).

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="LogicPrimer.Connectives"><span class="id" title="module">Connectives</span></a>.<br/>
<span class="id" title="keyword">Variables</span> <a name="LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a name="LogicPrimer.Connectives.Q"><span class="id" title="axiom">Q</span></a> <a name="LogicPrimer.Connectives.R"><span class="id" title="axiom">R</span></a>: <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The propositional conjunction of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, denoted by <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, is
a straightforward Curry-Howard counterpart of the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#pair"><span class="id" title="constructor">pair</span></a></span> datatype that
we have already seen in , and is defined by
means of the predicate <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "_ /\ _".<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode">&quot;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>&quot;</span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>  <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">type_scope</span></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=  <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> ∧ <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a><br/>
<br/>
<span class="id" title="var">For</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a>: <span class="id" title="var">Arguments</span> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>, <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> <span class="id" title="var">are</span> <span class="id" title="var">implicit</span><br/>
<span class="id" title="var">For</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a>: <span class="id" title="var">Argument</span> <span class="id" title="var">scopes</span> <span class="id" title="var">are</span> [<span class="id" title="var">type_scope</span> <span class="id" title="var">type_scope</span>]<br/>
<span class="id" title="var">For</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a>: <span class="id" title="var">Argument</span> <span class="id" title="var">scopes</span> <span class="id" title="var">are</span> [<span class="id" title="var">type_scope</span> <span class="id" title="var">type_scope</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span>]
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Proving a conjunction of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> therefore amounts to constructing
a pair by invoking the constructor <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a></span> and providing values of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>
and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> as its arguments:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a name="LogicPrimer.Connectives.Unnamed_thm"><span class="id" title="definition">P</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm"><span class="id" title="definition">→</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm"><span class="id" title="definition">R</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm"><span class="id" title="definition">→</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm"><span class="id" title="definition">P</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm"><span class="id" title="definition">∧</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm"><span class="id" title="definition">R</span></a>.<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">p</span> <span class="id" title="var">r</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The proof can be completed in several ways. The most familiar one is
to apply the constructor <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a></span> directly. It will create two subgoals,
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> (which are the constructor arguments), that can be
immediately discharged.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">apply</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#conj"><span class="id" title="constructor">conj</span></a>=&gt;//.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Alternatively, since we now know that <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a></span> has just one constructor,
we can use the generic Coq's <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span>
tactic, where <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> is an (optional) number of a constructor to be
applied (and in this case it's <span class="inlinecode">1</span>)

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Undo</span>.<br/>
<span class="id" title="tactic">constructor</span> 1=&gt;//.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Finally, for propositions that have exactly one constructor, Coq
provides a specialized tactic <span class="inlinecode"><span class="id" title="tactic">split</span></span>, which is a synonym for
<span class="inlinecode"><span class="id" title="tactic">constructor</span></span> <span class="inlinecode">1</span>:
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Undo</span>. <span class="id" title="tactic">split</span>=&gt;//.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

In order to prove something out of a conjunction, one needs to
<i>destruct</i> it to get its constructor's arguments, and the simplest way
to do so is by the <span class="inlinecode"><span class="id" title="tactic">case</span></span>-analysis on a single constructor.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a name="LogicPrimer.Connectives.Unnamed_thm0"><span class="id" title="definition">P</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm0"><span class="id" title="definition">∧</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm0"><span class="id" title="definition">Q</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm0"><span class="id" title="definition">→</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm0"><span class="id" title="definition">Q</span></a>.<br/>
<span class="id" title="tactic">case</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Again, the tactic <span class="inlinecode"><span class="id" title="tactic">case</span></span> replaced the top assumption <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> of the
goal with the arguments of its only constructor, <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> making
the rest of the proof trivial.

</div>
<div class="code">

<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">
The datatype of disjunction of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, denoted by <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, is
isomorphic to the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#sum"><span class="id" title="inductive">sum</span></a></span> datatype from  and
can be constructed by using one of its two constructors: <span class="inlinecode"><span class="id" title="var">or_introl</span></span>
or <span class="inlinecode"><span class="id" title="var">or_intror</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "_ \/ _".<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode">&quot;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>&quot;</span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#or"><span class="id" title="inductive">or</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>   <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">type_scope</span></span> 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#or"><span class="id" title="inductive">or</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#or"><span class="id" title="inductive">or</span></a> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> : <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">or_introl</span> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> ∨ <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> | <span class="id" title="var">or_intror</span> : <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> ∨ <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a><br/>
<br/>
<span class="id" title="var">For</span> <span class="id" title="var">or_introl</span>, <span class="id" title="var">when</span> <span class="id" title="var">applied</span> <span class="id" title="var">to</span> <span class="id" title="var">less</span> <span class="id" title="var">than</span> 1 <span class="id" title="var">argument</span>:<br/>
&nbsp;&nbsp;<span class="id" title="var">Arguments</span> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>, <a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a> <span class="id" title="var">are</span> <span class="id" title="var">implicit</span><br/>
...
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>



<div class="paragraph"> </div>

In order to prove disjunction of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, it is sufficient to
provide a proof of just <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> or <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, therefore appealing to the
appropriate constructor.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a name="LogicPrimer.Connectives.Unnamed_thm1"><span class="id" title="definition">Q</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm1"><span class="id" title="definition">→</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm1"><span class="id" title="definition">P</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm1"><span class="id" title="definition">∨</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm1"><span class="id" title="definition">Q</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm1"><span class="id" title="definition">∨</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm1"><span class="id" title="definition">R</span></a>.<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">q</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Similarly to the case of conjunction, this proof can be completed
either by applying a constructor directly, by using <span class="inlinecode"><span class="id" title="tactic">constructor</span></span> <span class="inlinecode">2</span>
tactic or by a specialised Coq's tactic for disjunction:
<span class="inlinecode"><span class="id" title="tactic">left</span></span> or <span class="inlinecode"><span class="id" title="tactic">right</span></span>. The notation <span class="inlinecode">&quot;<span class="id" title="var">_</span></span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">_</span>&quot;</span> is
right-associative, hence the following proof script, which first
reduces the goal to the proof of <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>, and then to the proof of
<span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, which is trivial by assumption.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">right</span>; <span class="id" title="tactic">left</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The use of Ssreflect's tactical <span class="inlinecode"><span class="id" title="tactic">by</span></span> makes sure that its
argument tactic (<span class="inlinecode"><span class="id" title="tactic">right</span>;</span> <span class="inlinecode"><span class="id" title="tactic">left</span></span> in this case) succeeds and the proof of
the goal completes, similarly to the trailing <span class="inlinecode"><span class="id" title="var">done</span></span>. If the sequence
of tactics <span class="inlinecode"><span class="id" title="tactic">left</span>;</span> <span class="inlinecode"><span class="id" title="tactic">right</span></span> wouldn't prove the goal, a proof script error
would be reported.

<div class="paragraph"> </div>

The statements that have a disjunction as their assumption are usually
proved by case analysis on the two possible disjunction's
constructors:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a name="LogicPrimer.Connectives.Unnamed_thm2"><span class="id" title="definition">P</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm2"><span class="id" title="definition">∨</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm2"><span class="id" title="definition">Q</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm2"><span class="id" title="definition">→</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm2"><span class="id" title="definition">Q</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm2"><span class="id" title="definition">∨</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm2"><span class="id" title="definition">P</span></a>.<br/>
<span class="id" title="tactic">case</span>⇒<span class="id" title="var">x</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Notice how the case analysis via the Ssreflect's <span class="inlinecode"><span class="id" title="tactic">case</span></span> tactic was
combined here with the trailing <span class="inlinecode">⇒</span>. It resulted in moving the
constructor parameter in <i>each</i> of the subgoals from the goal
assumptions to the assumption context. The types of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> are different
in the two branches of the proof, though. In the first branch, <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> has
type <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, as it names the argument of the <span class="inlinecode"><span class="id" title="var">or_introl</span></span> constructor.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> ∨ <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a><br/>
<br/>
<span class="id" title="keyword">subgoal</span> 2 (<span class="id" title="var">ID</span> 248) <span class="id" title="keyword">is</span>:<br/>
&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> ∨ <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">right</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> : <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> ∨ <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

In the second branch the type of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> is <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, as it accounts for the
case of the <span class="inlinecode"><span class="id" title="var">or_intror</span></span> constructor.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">left</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

It is worth noticing that the definition of disjunction in Coq is
<i>constructive</i>, whereas the disjunction in classical propositional
logic is not. More precisely, in classical logic the proof of the
proposition <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode">~</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is true by the axiom of excluded middle
(see  for a more detailed discussion),
whereas in Coq, proving <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode">~</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> would amount to <i>constructing</i> the
proof of either <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> or <span class="inlinecode">~</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>. Let us illustrate it with a specific
example. If <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is a proposition stating that <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><span class="id" title="var">NP</span></span>, then in
classical logic tautology <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode">~</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> holds, although it does not
contribute to the proof of either of the disjuncts. In constructive
logic, which Coq is an implementation of, in the trivial assumptions
given the proof of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode">~</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, we would be able to extract the proof
of either <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> or <span class="inlinecode">~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>.

<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab26"></a><h1 class="section">Proofs with negation</h1>


<div class="paragraph"> </div>

In Coq's constructive approach proving the negation of <span class="inlinecode">~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> of a
proposition <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> literally means that one can derive
the falsehood from <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "~ _".<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<span class="inlinecode">&quot;~</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>&quot;</span> <span class="inlinecode">:=</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>       <span class="inlinecode">:</span> <span class="inlinecode"><span class="id" title="var">type_scope</span></span>

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a> = <span class="id" title="keyword">fun</span> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Prop</span> ⇒ <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">Prop</span> → <span class="id" title="keyword">Prop</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Therefore, the negation <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#not"><span class="id" title="definition">not</span></a></span> on propositions from <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> is just a
function, which maps a proposition <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> to the implication <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span>
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>. With this respect the intuition of negation from classical
logic might be misleading: as it will be discussed in
, the Calculus of Constructions lacks the
double negation elimination axiom, which means that the proof of <span class="inlinecode">~</span> <span class="inlinecode">~<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> will not
deliver the proof of <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>, as such derivation would be non-constructive,
as one cannot get a value of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> out of a function
of type <span class="inlinecode">(<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a>)</span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>, where <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> is taken to be <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>.

<div class="paragraph"> </div>

However, reasoning out of negation helps to derive the familiar proofs
by contradiction, given that we managed to construct <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <i>and</i> <span class="inlinecode">~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>,
as demonstrated by the following theorem, which states that from any
<span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> can be derived from <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode">~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>. 

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LogicPrimer.Connectives.absurd"><span class="id" title="lemma">absurd</span></a>: <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.Q"><span class="id" title="axiom">Q</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>⇒<span class="id" title="var">p</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">move</span> : (<span class="id" title="var">H</span> <span class="id" title="var">p</span>). <span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

One extremely useful theorem from propositional logic involving
negation is <i>contraposition</i>. It states that in an implication, the
assumption and the goal can be flipped if inverted.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LogicPrimer.Connectives.contraP"><span class="id" title="lemma">contraP</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.Q"><span class="id" title="axiom">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.Q"><span class="id" title="axiom">Q</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>.<br/>

<br/>
</div>

<div class="doc">
Let us see how it can be proved in Coq 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">H</span> <span class="id" title="var">Hq</span>.<br/>
<span class="id" title="tactic">move</span> /<span class="id" title="var">H</span>.<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a> : <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">Hq</span> : ~ <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The syntax <span class="inlinecode"><span class="id" title="tactic">move</span></span> <span class="inlinecode">/</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> (spaces in between are optional) stands for one
of the most powerful features of Ssreflect, called <i>views</i> (see
), which allows one to <i>weaken</i> the
assumption in the goal part of the proof on the fly by applying a
hypothesis <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> to the top assumption in the goal. In the script above
the first command <span class="inlinecode"><span class="id" title="tactic">move</span>⇒</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> <span class="inlinecode"><span class="id" title="var">Hq</span></span> simply popped two assumptions from the
goal to the context. What is left is <span class="inlinecode">~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, or, equivalently <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span>
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>. The view mechanism then "interpreted" <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> in the goal via <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span>
and changing it to <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, since <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.H"><span class="id" title="axiom">H</span></a></span> was of type <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, which results
in the modified goal <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>.  Next, we apply the view <span class="inlinecode"><span class="id" title="var">Hq</span></span> to
the goal, which switches <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> to <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#False"><span class="id" title="inductive">False</span></a></span>, which makes the rest of the
proof trivial.  
</div>
<div class="code">

<br/>
<span class="id" title="tactic">move</span> /<span class="id" title="var">Hq</span>.<br/>
<span class="id" title="var">done</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>

<br/>

<br/>
</div>

<div class="doc">
<a name="lab27"></a><h1 class="section">Existential quantification</h1>



<div class="paragraph"> </div>

Existential quantification in Coq, which is denoted by the notation
"<span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>,</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>" is just yet another inductive predicate with exactly
one constructor:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Locate</span> "exists".<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode">"'exists' x .. y , p" := <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a> (<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> ⇒ .. (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a> (<span class="id" title="keyword">fun</span> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> ⇒ <a class="idref" href="PnP.Rewriting.html#p"><span class="id" title="variable">p</span></a>)) ..)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">type_scope</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ex_intro</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>, <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>



<div class="paragraph"> </div>

The notation for existentially quantified predicates conveniently
allows one to existentially quantify over several variables,
therefore, leading to a chain of enclosed calls of the constructor
<span class="inlinecode"><span class="id" title="var">ex_intro</span></span>.  

<div class="paragraph"> </div>

The inductive predicate <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span> is parametrized with a type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>, over
elements of which we quantify, and a predicate function of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span>
<span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. What is very important is that the scope of the variable <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> in
the constructor captures <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> as well. That is, the constructor
type could be written as <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>,</span> <span class="inlinecode">(<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>)</span> to emphasize that
each particular instance of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> carries is defined by a
<i>particular</i> value of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>. The actual value of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>, which satisfies
the predicate <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is, however, not exposed to the client, providing
the <i>data abstraction</i> and information hiding, similarly to the
traditional existential types (see ), which would serve as a good analogy.  Each
inhabitant of the type <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span> is therefore an instance of a
 whose first element is a
<i>witness</i> for the following predicate <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, and the second one is a
result of application of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> to <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>, yielding a particular
proposition.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

The proofs of propositions that assume existential quantification are
simply the proofs by case analysis: destructing the only constructor
of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span>, immediately provides its arguments: a witness <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and the
predicate <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>, satisfied by <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>. The proofs, where the existential
quantification is a goal, can be completed by applying the constructor
<span class="inlinecode"><span class="id" title="var">ex_intro</span></span> directly or by using a specialized Coq's tactic <span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#z"><span class="id" title="variable">z</span></a></span>,
which does exactly the same, instantiating the first parameter of the
constructor with the provided value <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#z"><span class="id" title="variable">z</span></a></span>. Let us demonstrate it on a
simple example, accounting for
the weakening of the predicate, satisfying the existentially
quantified variable.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Theorem</span> <a name="LogicPrimer.Connectives.ex_imp_ex"><span class="id" title="lemma">ex_imp_ex</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">S</span> <span class="id" title="var">T</span>: <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>): <br/>
&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="var">a</span>: <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="PnP.LogicPrimer.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="PnP.LogicPrimer.html#a"><span class="id" title="variable">a</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>: <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a>, <a class="idref" href="PnP.LogicPrimer.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">exists</span></a> <span class="id" title="var">b</span>: <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#a883bdd010993579f99d60b3775bcf54"><span class="id" title="notation">,</span></a> <a class="idref" href="PnP.LogicPrimer.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.LogicPrimer.html#b"><span class="id" title="variable">b</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The parentheses are important here, otherwise, for instance, the scope
of the first existentially-quantified variable <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> would be the whole
subsequent statement, not just the proposition <i>S a</i>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Proof</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

First, we decompose the first existential product into the witness <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span>
and the proposition <span class="inlinecode"><span class="id" title="var">Hst</span></span>, and also store the universally-quantified
implication assumption with the name <span class="inlinecode"><span class="id" title="var">Hst</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">case</span>⇒<span class="id" title="var">a</span> <span class="id" title="var">Hs</span> <span class="id" title="var">Hst</span>.<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">Hs</span> : <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">Hst</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>, <a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> → <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<span class="id" title="tactic">exists</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>, <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a>
<div class="paragraph"> </div>

</span>Next, we apply the <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span>'s constructor by means of the <span class="inlinecode"><span class="id" title="tactic">exists</span></span>
tactic with an explicit witness value <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span>: 

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">exists</span> <span class="id" title="var">a</span>.<br/>

<br/>
</div>

<div class="doc">
We finish the proof  by applying the weakening hypothesis <span class="inlinecode"><span class="id" title="var">Hst</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span>: <span class="id" title="var">Hst</span>.<br/>

<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">


<div class="paragraph"> </div>

Let us define our own version <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.my_ex"><span class="id" title="inductive">my_ex</span></a></span> of the existential quantifier
using the Ssreflect notation for constructors:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="LogicPrimer.Connectives.my_ex"><span class="id" title="inductive">my_ex</span></a> <span class="id" title="var">A</span> (<span class="id" title="var">S</span>: <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> := <a name="LogicPrimer.Connectives.my_ex_intro"><span class="id" title="constructor">my_ex_intro</span></a> <span class="id" title="var">x</span> <span class="id" title="keyword">of</span> <a class="idref" href="PnP.LogicPrimer.html#S"><span class="id" title="variable">S</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The reader is invited to prove the following goal, establishing the
equivalence of the two propositions

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">∀</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">A</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">(</span></a><a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">S</span></a><a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">:</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">A</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">→</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">Prop</span></a><a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">),</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">my_ex</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">A</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">S</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">↔</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">exists</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">y</span></a><a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">:</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">A</span></a><a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">,</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">S</span></a> <a name="LogicPrimer.Connectives.Unnamed_thm3"><span class="id" title="definition">y</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 the propositional equivalence <span class="inlinecode">↔</span> is just a conjunction of
two implications, so proving it can be reduced to two separate goals
by means of <span class="inlinecode"><span class="id" title="tactic">split</span></span> tactics.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>

<a name="lab28"></a><h2 class="section">A conjunction and disjunction analogy</h2>


<div class="paragraph"> </div>

Sometimes, the universal and the existential quantifications are
paraphrased as "infinitary" conjunction and disjunction
correspondingly. This analogy comes in handy when understanding the
properties of both quantifications, so let us elaborate on it for a bit.

<div class="paragraph"> </div>

In order to prove the conjunction <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#P1"><span class="id" title="variable">P1</span></a></span> <span class="inlinecode">∧</span> <span class="inlinecode">...</span> <span class="inlinecode">∧</span> <span class="inlinecode"><span class="id" title="var">Pn</span></span>, one needs to
establish that <i>all</i> propositions <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#P1"><span class="id" title="variable">P1</span></a></span> <span class="inlinecode">...</span> <span class="inlinecode"><span class="id" title="var">Pn</span></span> hold, which in the
finite case can be done by proving <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> goals, for each statement
separately (and this is what the <span class="inlinecode"><span class="id" title="tactic">split</span></span> tactic helps to
do). Similarly, in order to prove the propositions <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>:</span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>,</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>,
one needs to prove that <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> holds for <i>any</i> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>. Since
the type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> itself can define an infinite set, there is no way to
enumerate all conjuncts, however, an explicit handle <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> gives a way
to effectively <i>index</i> them, so proving <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> for an arbitrary <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> would
establish the validity of the universal quantification itself. Another
useful insight is that in Coq <span class="inlinecode"><span class="id" title="keyword">∀</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>:</span> <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>,</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> is a type of a
dependent function that maps <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> of type <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> to a value of type <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>. The proof of the quantification would be, therefore, a function
with a suitable "plot". Similarly, in the case of <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span>-ary conjunction,
the function has finite domain of exactly <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span> points, for each of
which an appropriate proof term should be found.

<div class="paragraph"> </div>

In order to prove the <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a></span>-ary disjunction <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#P1"><span class="id" title="variable">P1</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode">...</span> <span class="inlinecode">∨</span> <span class="inlinecode"><span class="id" title="var">Pn</span></span> in Coq, it
is sufficient to provide a proof for just one of the disjunct <i>as well
as</i> a "tag" --- an indicator, which disjunct exactly is being proven
(this is what tactics <span class="inlinecode"><span class="id" title="tactic">left</span></span> and <span class="inlinecode"><span class="id" title="tactic">right</span></span> help to achieve). In the case
of infinitary disjunction, the existential quantification "<span class="inlinecode"><span class="id" title="tactic">exists</span></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>,</span>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>", the existentially quantified variable plays role of the tag
indexing all possible propositions <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>. Therefore, in order to prove
such a proposition, one needs first to deliver a witness <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> (usually,
by means of calling the tactics <span class="inlinecode"><span class="id" title="tactic">exists</span></span>), and then prove that for
this witness/tag the proposition <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> holds. Continuing the same
analogy, the disjunction in the assumption of a goal usually leads to
the proof by <span class="inlinecode"><span class="id" title="tactic">case</span></span> analysis assuming that one of the disjuncts holds
at a time. Similarly, the way to destruct the existential
quantification is by case-analysing on its constructor, which results
in acquiring the witness (i.e., the "tag") and the corresponding
"disjunct".

<div class="paragraph"> </div>

Finally, the folklore alias "dependent product type" for dependent
function types (i.e., <span class="inlinecode"><span class="id" title="keyword">∀</span></span>-quantified types) indicates its
relation to products, which are Curry-Howard counterparts of
conjunctions. In the same spirit, the term "dependent sum type" for
the dependent types, of which existential quantification is a
particular case, hints to the relation to the usual sum types, and, in
particular <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#sum"><span class="id" title="inductive">sum</span></a></span> (discussed in ), which is a
Curry-Howard dual of a disjunction.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives"><span class="id" title="module">Connectives</span></a>.<br/>

<br/>
</div>

<div class="doc">
<a name="lab29"></a><h1 class="section">Missing axioms from classical logic</h1>



<div class="paragraph"> </div>

In the previous sections of this chapter, we have seen how a fair
amount of propositions from the higher-order propositional logics can
be encoded and proved in Coq. However, some reasoning principles,
employed in <i>classical</i> propositional logic, cannot be encoded in
Coq in a form of provable statements, and, hence, should be encoded as
<i>axioms</i>.

<div class="paragraph"> </div>

 In this section, we provide a
brief and by all means incomplete overview of the classical
propositional logic axioms that are missing in Coq, but can be added
by means of importing the appropriate libraries.  contains a detailed survey of useful axioms
that can be added into Coq development on top of CIC.

<div class="paragraph"> </div>

To explore some of some of the axioms, we first import that classical
logic module <span class="inlinecode"><span class="id" title="library">Classical_Prop</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>
<span class="id" title="keyword">Import</span> <span class="id" title="var">Classical_Prop</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The most often missed axiom is the axiom of <i>excluded middle</i>, which
postulates that the disjunction of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> and <span class="inlinecode">~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is provable. Adding
this axiom circumvents the fact that the reasoning out of the excluded
middle principle is <i>non-constructive</i>, as discussed in
.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Logic.Classical_Prop.html#classic"><span class="id" title="axiom">classic</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Logic.Classical_Prop.html#classic"><span class="id" title="axiom">classic</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> : <span class="id" title="keyword">Prop</span>, <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> ∨ ~ <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Another axiom from the classical logic, which coincides with the type
of Scheme's <span class="inlinecode"><span class="id" title="var">call</span>/<span class="id" title="var">cc</span></span>
operator
(pronounced as <i>call with current continuation</i>) modulo Curry-Howard
isomorphism is <i>Peirce's law</i>:


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.peirce_law"><span class="id" title="definition">peirce_law</span></a> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>: <span class="id" title="keyword">Prop</span>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">((</span></a><a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

In Scheme-like languages, the <span class="inlinecode"><span class="id" title="var">call</span>/<span class="id" title="var">cc</span></span> operator allows one to
invoke the undelimited continuation, which aborts the
computation. Similarly to the fact that <span class="inlinecode"><span class="id" title="var">call</span>/<span class="id" title="var">cc</span></span> cannot be
implemented in terms of polymorphically-typed lambda calculus as a
function and should be added as an external operator, the Peirce's law
is an axiom in the constructive logic.

<div class="paragraph"> </div>

The classical double negation principle is easily derivable from
Peirce's law, and corresponds to the type of <span class="inlinecode"><span class="id" title="var">call</span>/<span class="id" title="var">cc</span></span>, which always
invokes its continuation parameter, aborting the current computation.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Logic.Classical_Prop.html#NNPP"><span class="id" title="lemma">NNPP</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Logic.Classical_Prop.html#NNPP"><span class="id" title="lemma">NNPP</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> : <span class="id" title="keyword">Prop</span>, ~ ~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Finally, the classical formulation of the implication through the
disjunction is again an axiom in the constructive logic, as otherwise
from the function of type <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span> one would be able to construct the
proof of <span class="inlinecode">~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> <span class="inlinecode">∨</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a></span>, which would make the law of excluded middle
trivial to derive.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Logic.Classical_Prop.html#imply_to_or"><span class="id" title="lemma">imply_to_or</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Logic.Classical_Prop.html#imply_to_or"><span class="id" title="lemma">imply_to_or</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a> : <span class="id" title="keyword">Prop</span>, (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> → <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a>) → ~<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> ∨ <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Q"><span class="id" title="definition">Q</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Curiously, none of these axioms, if added to Coq, makes its logic
unsound: it has been rigorously proven (although, not within Coq, due
to 's incompleteness result) that all classical logic axioms
are consistent with CIC, and, therefore, don't make it possible to
derive the falsehood.

<div class="paragraph"> </div>

The following exercise reconciles most of the familiar axioms of 
classical logic.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Prove that the following five axioms of the classical are equivalent.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.peirce"><span class="id" title="definition">peirce</span></a> := <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.peirce_law"><span class="id" title="definition">peirce_law</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.double_neg"><span class="id" title="definition">double_neg</span></a> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span>: <span class="id" title="keyword">Prop</span>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.excluded_middle"><span class="id" title="definition">excluded_middle</span></a> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span>: <span class="id" title="keyword">Prop</span>, <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">∨</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.de_morgan_not_and_not"><span class="id" title="definition">de_morgan_not_and_not</span></a> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>: <span class="id" title="keyword">Prop</span>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">(</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ba2b0e492d2b4675a0acf3ea92aabadd"><span class="id" title="notation">∧</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">∨</span></a> <a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.implies_to_or"><span class="id" title="definition">implies_to_or</span></a> := <span class="id" title="keyword">∀</span> <span class="id" title="var">P</span> <span class="id" title="var">Q</span>: <span class="id" title="keyword">Prop</span>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#63a68285c81db8f9bc456233bb9ed181"><span class="id" title="notation">~</span></a><a class="idref" href="PnP.LogicPrimer.html#P"><span class="id" title="variable">P</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#f031fe1957c4a4a8e217aa46af2b4e25"><span class="id" title="notation">∨</span></a> <a class="idref" href="PnP.LogicPrimer.html#Q"><span class="id" title="variable">Q</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a>.<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 Use <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">/<span class="id" title="var">d</span></span>  tactics to unfold the
 definition of a value <span class="inlinecode"><span class="id" title="var">d</span></span> and replace its name by its body. You can
 chain several unfoldings by writing <span class="inlinecode"><span class="id" title="tactic">rewrite</span></span> <span class="inlinecode">/<span class="id" title="var">d1</span></span> <span class="inlinecode">/<span class="id" title="var">d2</span></span> <span class="inlinecode">...</span>
 etc. 

<div class="paragraph"> </div>

 To facilitate the forward reasoning by contradiction, you can
 use the Ssreflect tactic <span class="inlinecode"><span class="id" title="var">suff</span>:</span> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span>,  where <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> is
 an arbitrary proposition. The system will then require you to prove
 that <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> implies the goal <i>and</i> <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a></span> itself.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

 Stuck with a tricky proof? Use the Coq <span class="inlinecode"><span class="id" title="var">Admitted</span></span> keyword as a
 "stub" for an unfinished proof of a goal, which, nevertheless will be
 considered completed by Coq. You can always get back to an admitted
 proof later.

<div class="paragraph"> </div>



<div class="paragraph"> </div>


<div class="paragraph"> </div>

<a name="lab30"></a><h1 class="section">Universes and <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> impredicativity</h1>


<div class="paragraph"> </div>

While solving Exercise from the previous section,
the reader could notice an interesting detail about the propositions
in Coq and the sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>: the propositions that quantify over
propositions still remain to be propositions, i.e., they still belong
to the sort <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>. This property of propositions in Coq (and, in
general, the ability of entities of some class to abstract over the
entities of the same class) is called
<i>impredicativity</i>.  The opposite
characteristic (i.e., the inability to refer to the elements of the
same class) is called <i>predicativity</i>. 

<div class="paragraph"> </div>

One of the main challenges when designing the Calculus of
Constructions was to implement its logical component (i.e., the
fragment responsible for constructing and operating with elements of
the <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> sort), so it would subsume the existing impredicative
propositional calculi, and, in

particular,  (which is impredicative), allowing for the
expressive reasoning in higher-order propositional logic.

<div class="paragraph"> </div>

<i>Impredicativity</i> as a property of definitions allows one to define
domains that are <i>self-recursive</i>---a feature of <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> that we
recently observed. Unfortunately, when restated in the classical set
theory, impredicativity immediately leads to the famous paradox by Russell,
which arises from the attempt to define the set of all sets
that do not belong to themselves. In terms of programming,
Russell's paradox provides a recipe to encode a fixpoint combinator in
the calculus itself and write generally-recursive programs.

<div class="paragraph"> </div>

 is not a dependently-typed calculus and it has been
proven to contain no paradoxes, as it reasons only
about <i>types</i> (or, <i>propositions</i>), which do not depend on
values. However, adding dependent types to the mix (which Coq requires
to make propositions quantify over arbitrary values, not just other
propositions, serving as a general-purpose logic) makes the design of
a calculus more complicated, in order to avoid paradoxes akin to the
Russell's, which arise from mixing values and sets of values. This
necessity to "cut the knot" inevitably requires to have a sort of a
higher level, which contains all sets and propositions (i.e., the
whole sorts <span class="inlinecode"><span class="id" title="keyword">Set</span></span> and <span class="inlinecode"><span class="id" title="keyword">Prop</span></span>), but does not contain itself. Let us
call such sort <span class="inlinecode"><span class="id" title="keyword">Type</span></span>. It turns out that the self-inclusion <span class="inlinecode"><span class="id" title="keyword">Type</span></span> <span class="inlinecode">:</span>
<span class="inlinecode"><span class="id" title="keyword">Type</span></span> leads to another class of paradoxes, and
in order to avoid them, the hierarchy of higher-order sorts should be
made infinite and <i>stratified</i>. 
Stratification means that each sort has a level number, and is
contained in a sort of a higher level but not in itself. The described
approach is suggested by  and
adopted literally, in particular, by
Agda. The stratified type sorts,
following 's tradition, are usually referred to as
<i>universes</i>.

<div class="paragraph"> </div>

A similar stratification is also implemented in Coq, which has its own
universe hierarchy, although with an important twist. The two
universes, <span class="inlinecode"><span class="id" title="keyword">Set</span></span> and <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> cohabit at the first level of the universe
hierarchy with <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> being impredicative. The universe containing
both <span class="inlinecode"><span class="id" title="keyword">Set</span></span> and <span class="inlinecode"><span class="id" title="keyword">Prop</span></span> is called <span class="inlinecode"><span class="id" title="keyword">Type</span></span><span class="inlinecode">@{<span class="id" title="keyword">Set</span>+1}</span>, and it is <i>predicative</i>, as
well as all universes that are above it in the hierarchy. CIC
therefore remains consistent as a calculus, only because of the fact
that all impredicativity in it is contained at the very bottom of the
hierarchy.

<div class="paragraph"> </div>

<a name="lab31"></a><h2 class="section">Exploring and debugging the universe hierarchy</h2>


<div class="paragraph"> </div>

In the light of 's stratification, the Coq'
non-polymorphic types, such as <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a></span>, <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span> or <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a></span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>
"live" at the <span class="inlinecode">0</span>th level of universe hierarchy, namely, in the sort
<span class="inlinecode"><span class="id" title="keyword">Set</span></span>. The polymorphic types, quantifying over the elements of the
<span class="inlinecode"><span class="id" title="keyword">Set</span></span> universe are, therefore located at the higher level, which in
Coq is denoted as <span class="inlinecode"><span class="id" title="keyword">Type</span></span><span class="inlinecode">@{<span class="id" title="keyword">Set</span>+1}</span>, but in the displays is usually presented
simply as <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, as well as all the higher universes. We can enable
the explicit printing of the universe levels to see how they are
assigned:

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Printing Universes</span>.<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">Set</span>
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Set</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Set</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">Type@</span>{<span class="id" title="keyword">Set</span>+1}
<div class="paragraph"> </div>

</span>
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <span class="id" title="keyword">Prop</span>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Prop</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">Type@</span>{<span class="id" title="keyword">Set</span>+1}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The following type is polymorphic over the elements of the <span class="inlinecode"><span class="id" title="keyword">Set</span></span>
universe, and this is why its own universe is "bumped up" by one, so
it now belongs to <span class="inlinecode"><span class="id" title="keyword">Set</span>+1</span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.S"><span class="id" title="definition">S</span></a> := <span class="id" title="keyword">∀</span> <span class="id" title="var">T</span>: <span class="id" title="keyword">Set</span>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#list"><span class="id" title="inductive">list</span></a> <a class="idref" href="PnP.LogicPrimer.html#T"><span class="id" title="variable">T</span></a>.<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.S"><span class="id" title="definition">S</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.S"><span class="id" title="axiom">S</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">Type@</span>{<span class="id" title="keyword">Set</span>+1}
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

 

<div class="paragraph"> </div>

Until version 8.5, Coq used to provide a very limited version of
<i>universe polymorphism</i>. To illustrate the idea, let us consider the
next definition <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>, which is polymorphic with respect to the universe
of its parameter <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>, so its result is assumed to "live" in the
universe, whose level is taken to be the level of <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.R"><span class="id" title="definition">R</span></a> (<span class="id" title="var">A</span>: <span class="id" title="keyword">Type</span>) (<span class="id" title="var">x</span>: <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a>): <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a> := <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="var">Arguments</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> [<span class="id" title="var">A</span>].<br/>

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#tt"><span class="id" title="constructor">tt</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> <a class="idref" href="PnP.FunProg.html#tt"><span class="id" title="constructor">tt</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a>
<div class="paragraph"> </div>

</span>

<div class="paragraph"> </div>

The part in comments show the inequality, generated by the Coq
unification algorithm that had to be solved in order to determine the
universe level of the value <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#tt"><span class="id" title="constructor">tt</span></a></span> with <span class="inlinecode"><span class="id" title="var">Top</span>.93</span> being the level,
assigned to <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> itself.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

If the argument of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> is itself a universe, it means that <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span>'s
level is higher than <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>'s level, and so is the level of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>'s result.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> <span class="id" title="keyword">Type</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> <span class="id" title="var">Type@</span>{<span class="id" title="var">Top</span>.94}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="var">Type@</span>{<span class="id" title="var">Top</span>.95}
<div class="paragraph"> </div>

</span>

<div class="paragraph"> </div>

The Coq's unifier algorithm in this case looks for a universe levels
<span class="inlinecode"><span class="id" title="var">Top</span>.95</span>, which can be larger than the level of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>'s argument level
<span class="inlinecode"><span class="id" title="var">Top</span>.94</span>, but smaller than the one of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> itself (i.e., <span class="inlinecode"><span class="id" title="var">Top</span>.93</span>). In
the absence of other constraints, such system of equalities is easily
satisfiable.

<div class="paragraph"> </div>

However, the attempt to apply <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> to <i>itself</i> immediately leads to an
error reported, as the system cannot infer the level of the result, by
means of solving a system of universe level inequations, therefore,
preventing meta-circular paradoxes.

<div class="paragraph"> </div>


<div class="paragraph"> </div>


<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Check</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a>.<br/>
<br/>
<span class="id" title="var">The</span> <span class="id" title="var">term</span> "R" <span class="id" title="var">has</span> <span class="id" title="keyword">type</span> "forall A : Type@{Top.93}, A -&gt; A"<br/>
<span class="id" title="var">while</span> <span class="id" title="var">it</span> <span class="id" title="keyword">is</span> <span class="id" title="var">expected</span> <span class="id" title="var">to</span> <span class="id" title="var">have</span> <span class="id" title="keyword">type</span> "?A"<br/>
(<span class="id" title="var">unable</span> <span class="id" title="var">to</span> <span class="id" title="var">find</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> <span class="id" title="var">well</span>-<span class="id" title="var">typed</span> <span class="id" title="var">instantiation</span> <span class="id" title="keyword">for</span> "?A": <span class="id" title="var">cannot</span> <span class="id" title="var">ensure</span> <span class="id" title="var">that</span><br/>
"Type@{Top.93+1}" <span class="id" title="keyword">is</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> <span class="id" title="var">subtype</span> <span class="id" title="keyword">of</span> "Type@{Top.93}").
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The solution to this problem is to think of the two occurrences <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span> in
the last example as of inhabitants of <i>different</i> universes, so that
the <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>-"function" belongs to the universe with a higher level number
than <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>-"argument". Checking this scenario requires supporting a more
flexible form of universe polymorphism, which can assign different
universe levels to different occurrences of the same definition in a
common expression, and in this sense reminds <i>let-polymorphism</i>
.  This
feature was introduced in Coq since version
8.5, and it allows us to redefine <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.R"><span class="id" title="definition">R</span></a></span>
as universe-polymorphic via the new <span class="inlinecode"><span class="id" title="var">Polymorphic</span></span> 
keyword.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="var">Polymorphic</span> <span class="id" title="keyword">Definition</span> <a name="LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a> {<span class="id" title="var">A</span> : <span class="id" title="keyword">Type</span>} (<span class="id" title="var">a</span> : <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a>) : <a class="idref" href="PnP.LogicPrimer.html#A"><span class="id" title="variable">A</span></a> := <a class="idref" href="PnP.LogicPrimer.html#a"><span class="id" title="variable">a</span></a>.<br/>

<br/>
<span class="id" title="keyword">About</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a> : <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">Top</span>.96}, <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>
<div class="paragraph"> </div>

</span>

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">universe</span> <span class="id" title="var">polymorphic</span><br/>
<span class="id" title="var">Argument</span> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">implicit</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#and"><span class="id" title="inductive">and</span></a> <span class="id" title="var">maximally</span> <span class="id" title="var">inserted</span><br/>
...
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

We can now apply <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a></span> to itself using the following syntax.

</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="LogicPrimer.selfRPoly"><span class="id" title="definition">selfRPoly</span></a> := <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a> (@<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a>).<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.selfRPoly"><span class="id" title="definition">selfRPoly</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Let us now check the details of universes participating in
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.selfRPoly"><span class="id" title="definition">selfRPoly</span></a></span>'s typing.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.selfRPoly"><span class="id" title="definition">selfRPoly</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.selfRPoly"><span class="id" title="definition">selfRPoly</span></a> = <br/>
<span class="id" title="var">RPoly@</span>{<span class="id" title="var">Top</span>.97} (@<span class="id" title="var">RPoly@</span>{<span class="id" title="var">Top</span>.98})<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="var">Type@</span>{<span class="id" title="var">Top</span>.98}, <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>
<div class="paragraph"> </div>

</span>

<div class="paragraph"> </div>

The display above demonstrates that the two occurrences of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.RPoly"><span class="id" title="definition">RPoly</span></a></span>
were assumed by the typing algorithm to belong to different universes:
<span class="inlinecode"><span class="id" title="var">Top</span>.97</span> for the function and <span class="inlinecode"><span class="id" title="var">Top</span>.98</span> for the argument,
correspondingly. In the absence of additional additional constraints,
the inequality between them can be trivially satisfied by assuming
<span class="inlinecode"><span class="id" title="var">Top</span>.98</span> <span class="inlinecode">&lt;</span> <span class="inlinecode"><span class="id" title="var">Top</span>.97</span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>

<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
<script src="https://jscoq.github.io/node_modules/jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
<script src="../js/jscoq-embed.js" type="text/javascript"></script>
</html>
