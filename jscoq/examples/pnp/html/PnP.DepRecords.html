<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link href="../js/clean.css" rel="stylesheet" type="text/css" />
<title>PnP.DepRecords</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<h1 class="libtitle">Library PnP.DepRecords</h1>

<div class="code">

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 

<div class="paragraph"> </div>


<div class="paragraph"> </div>

Long before programming has been established as a discipline,
mathematics came to be perceived as a science of building
abstractions and summarizing important properties of various entities
necessary for describing nature's phenomenons. From the basic course of algebra, we are
familiar with a number of mathematical structures, such as monoids,
groups, rings, fields etc., which couple a <i>carrier</i> set (or a number of
sets), a number of operations on it (them), and a collection of
properties of the set itself and operations on them.

<div class="paragraph"> </div>

From a working programmer's perspective, a notion of a mathematical
abstract structure is reminiscent to a notion of a class from
object-oriented programming, modules from Standard ML and type
classes from Haskell: all these
mechanisms are targeted to solve the same goal: <i>package</i> a number of
operations manipulating with some data, while abstracting of a
particular implementation of this data itself. What neither of these
programming mechanisms is capable of doing, comparing to mathematics,
is enforcing the requirement for one to provide the <i>proofs</i> of
properties, which restrict the operations on the data structure. For
instance, one can implement a type class for a <i>lattice</i> in Haskell as
follows: 

<div class="paragraph"> </div>

<pre>
  class Lattice a where
    bot :: a
    top :: a
    pre :: a -&gt; a -&gt; Bool
    lub :: a -&gt; a -&gt; a
    glb :: a -&gt; a -&gt; a
</pre>

<div class="paragraph"> </div>

That is, the class  is parametrized by a <i>carrier</i>
type , and provides the abstract interfaces for top and
bottom elements of the lattice, as well as for the ordering predicate
 and the binary <i>least-upper-bound</i> and
<i>greatest-lower-bound</i> operations. What this class cannot capture is a
number of restrictions, for instance, that the  relation
should be transitive, reflexive and antisymmetric. That said, one can
instantiate the  class, e.g., for integers,
 providing an implementation of , which
is <i>not</i> a partial order (e.g., just constant ). While
this relaxed approach is supposedly fine for the programming needs, as
the type classes are used solely for computing, not the reasoning
about the correctness of the computations, this is certainly
unsatisfactory from the mathematical perspective. Without the
possibility to establish and enforce the necessary properties of a
mathematical structure's operations, we would not be able to carry out
any sort of sound formal reasoning, as we simply could not distinguish
a "correct" implementation from a flawed one.

<div class="paragraph"> </div>

Luckily, Coq's ability to work with dependent types and combine
programs and propositions about them in the same language, as we've
already witnessed in the previous chapters, makes it possible to
define mathematical structures with a necessary degree of rigour and
describe their properties precisely by means of stating them as
<i>types</i> (i.e., propositions) of the appropriate implementation's
parameters. Therefore, any faithful instance of an abstract
mathematical structure implemented this way, would be enforced to
provide not just the <i>carrier</i> and implementations of the declared
operations but also <i>proofs</i> of propositions that constrain these
operations and the carrier.

<div class="paragraph"> </div>

In this chapter we will learn how to encode common algebraic data
structures in Coq in a way very similar to how data structures are
encoded in languages like C (with a bit of Haskell-ish type class-like
machinery), so the representation, unlike the one in C or Haskell,
would allow for flexible and generic reasoning about the structures'
properties. In the process, we will meet some old friends from the
course of abstract algebra---partial commutative monoids, and implement
them using Coq's native constructs: dependent records and canonical
structures.

<div class="paragraph"> </div>

As usual, we will require a number of Ssreflect package imported.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">From</span> <span class="id" title="var">mathcomp</span><br/>
<span class="id" title="keyword">Require</span> <span class="id" title="keyword">Import</span> <span class="id" title="library">ssreflect</span> <span class="id" title="library">ssrbool</span> <span class="id" title="library">ssrnat</span> <span class="id" title="library">eqtype</span> <span class="id" title="library">ssrfun</span>.<br/>

<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

We will also require to execute a number of Vernacular commands
simplifying the handling of implicit datatype arguments.

<div class="paragraph"> </div>





<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Set Implicit Arguments</span>.<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="keyword">Strict</span> <span class="id" title="keyword">Implicit</span>.<br/>
<span class="id" title="keyword">Unset</span> <span class="id" title="keyword">Printing</span> <span class="id" title="keyword">Implicit</span> <span class="id" title="var">Defensive</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab63"></a><h1 class="section">Encoding partial commutative monoids</h1>



<div class="paragraph"> </div>




<div class="paragraph"> </div>

We will be using partial commutative monoids (PCMs) as an illustrative
example of a simple algebraic data structure, a subject of encoding
and formalization. A PCM is defined as an algebraic structure with a
carrier set <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a></span>, abstract binary "join" operation  and a unit
element .
 The join operation is required to be
associative and commutative, and for the unit element the left and
right identity equalities should hold. Moreover, partiality means that
the operation  might be undefined for some pairs of elements
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a></span> (and in this case it is denoted as ). PCMs are fairly ubiquitous: in particular, natural numbers
with addition and multiplication, sets with a disjoin union,
partially-defined functions with a point-wise union, are all PCM
instances. Furthermore, partial commutative monoids are omnipresent in
program verification, as they capture
exactly the properties of <i>heaps</i>, as well as the effect of programs
that can be executed in
parallel. Therefore, it is useful to have
PCMs formalized as a structure, so they could be employed for future
reasoning.

<div class="paragraph"> </div>



<div class="paragraph"> </div>



<div class="paragraph"> </div>

<a name="lab64"></a><h2 class="section">Describing algebraic data structures via dependent records</h2>


<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="DepRecords.PCMDef"><span class="id" title="module">PCMDef</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

In  we have
already seen a use of a dependent pair type, exemplified by the Coq's
definition of the universal quantification.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><span class="id" title="keyword">Inductive</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a> (<a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> : <span class="id" title="keyword">Type</span>) (<a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a> → <span class="id" title="keyword">Prop</span>) : <span class="id" title="keyword">Prop</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">ex_intro</span> : <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a>, <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a> <a class="idref" href="PnP.LogicPrimer.html#LogicPrimer.Connectives.P"><span class="id" title="axiom">P</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The only constructor <span class="inlinecode"><span class="id" title="var">ex_intro</span></span> of the predicate <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#ex"><span class="id" title="inductive">ex</span></a></span>, whose type is a
dependent function type, is a way to encode a -type of a
dependent pair, such that its second component's type <i>depends</i> on the
value of the first one. More specifically, the
result of the existential quantification's encoding in Coq is a
dependent pair , such that the proposition in
the second component is determined by the value of the first
component<span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span>.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

Coq provides an alternative way to encode <i>iterated</i> dependent pairs
via the mechanism of <i>dependent records</i>, also allowing one to give
names to the subsequent components. Dependent records are defined
using the <span class="inlinecode"><span class="id" title="keyword">Record</span></span> command. Getting back to our PCM example, we
illustrate the use of dependent records by the following definition of
the abstract PCM structure.

<div class="paragraph"> </div>




<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Record</span> <a name="DepRecords.PCMDef.mixin_of"><span class="id" title="record">mixin_of</span></a> (<span class="id" title="var">T</span> : <span class="id" title="keyword">Type</span>) := <a name="DepRecords.PCMDef.Mixin"><span class="id" title="constructor">Mixin</span></a> {<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="DepRecords.PCMDef.valid_op"><span class="id" title="projection">valid_op</span></a> : <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a> : <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a name="DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a> : <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#commutative"><span class="id" title="definition">commutative</span></a> <a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="method">join_op</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#associative"><span class="id" title="definition">associative</span></a> <a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="method">join_op</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#left_id"><span class="id" title="definition">left_id</span></a> <a class="idref" href="PnP.DepRecords.html#unit_op"><span class="id" title="method">unit_op</span></a> <a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="method">join_op</span></a>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="PnP.DepRecords.html#valid_op"><span class="id" title="method">valid_op</span></a> (<a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="method">join_op</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#valid_op"><span class="id" title="method">valid_op</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a>; <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="var">_</span> : <a class="idref" href="PnP.DepRecords.html#valid_op"><span class="id" title="method">valid_op</span></a> <a class="idref" href="PnP.DepRecords.html#unit_op"><span class="id" title="method">unit_op</span></a> <br/>
}.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span><br/>
<span class="id" title="var">mixin_of_rect</span> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span><br/>
<span class="id" title="var">mixin_of_ind</span> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span><br/>
<span class="id" title="var">mixin_of_rec</span> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span><br/>
<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.valid_op"><span class="id" title="projection">valid_op</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span><br/>
<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span><br/>
<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a> <span class="id" title="keyword">is</span> <span class="id" title="var">defined</span>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>



<div class="paragraph"> </div>

The syntax of Coq's dependent records is reminiscent to the one of
records in C. Following Ssreflect's naming
pattern, we call the record type (defined
in a dedicated module for the reasons explained further) <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a></span>
and its only constructor <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Mixin"><span class="id" title="constructor">Mixin</span></a></span>. The reasons for such naming
convention will be explained soon, and for now let us discuss the
definition. The PCM record type is parametrized over the carrier type
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>, which determines the carrier set of a PCM. It then lists three
<i>named</i> fields: <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a></span> describes an implementation of the PCM's
binary operation, <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a></span> defines the unit element, finally, the
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.valid_op"><span class="id" title="projection">valid_op</span></a></span> predicate determines whether a particular element of the
carrier set <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> is valid or not, and, thus, serves as a way to express
the partiality of the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a></span> operation (the result is undefined,
whenever the corresponding value of <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> is non-valid). Next, the PCM
record lists five unnamed PCM <i>properties</i>, which should be satisfied
whenever the record is instantiated and are defined using the standard
propositions from Ssreflect's <span class="inlinecode"><span class="id" title="library">ssrfun</span></span>  module (see
). In particular, the PCM type definition
requires the operation to be <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#commutative"><span class="id" title="definition">commutative</span></a></span> and <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#associative"><span class="id" title="definition">associative</span></a></span>. It also
states that if  then  (the same
statement about  can be proved by commutativity), and that the unit
element is a valid one.

<div class="paragraph"> </div>

Notice that in the definition of the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a></span> record type, the types
of some of the later fields (e.g., any of the properties) depend on
the values of fields declared earlier (e.g., <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a></span>),
which makes <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a></span> to be a truly dependent type.

<div class="paragraph"> </div>

Upon describing the record, a number of auxiliary definitions have been
generated by Coq automatically. Along with the usual recursion and
induction principles, the system also generated three <i>getters</i>,
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.valid_op"><span class="id" title="projection">valid_op</span></a></span>, <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a></span>  for the record's
named fields. That is, similarly to Haskell's syntax, given an
instance of a PCM, one can extract, for example, its operation, via
the following getter function.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Check</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.valid_op"><span class="id" title="projection">valid_op</span></a>.<br/>

<br/>
</div>

<div class="doc">
<br/>
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.valid_op"><span class="id" title="projection">valid_op</span></a><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> : <span class="id" title="keyword">Type</span>, <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> → <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> → <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

Coq supports the syntax for anonymous record fields (via the
underscore <span class="inlinecode"><span class="id" title="var">_</span></span>), so getters for them are not generated. We have
decided to make the property fields of <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a></span> to be anonymous,
since they will usually appear only in the proofs, where the structure
is going to be decomposed by case analysis anyway, as we will soon
see.

<div class="paragraph"> </div>

We can now prove a number of facts about the structure, very much in
the spirit of the facts that are being proven in the algebra course.
For instance, the following lemma states that <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a></span> is also the
<i>right unit</i>, in addition to it being the left unit, as encoded by the
structure's definition.

<div class="paragraph"> </div>




<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.r_unit"><span class="id" title="lemma">r_unit</span></a> <span class="id" title="var">T</span> (<span class="id" title="var">pcm</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.mixin_of"><span class="id" title="record">mixin_of</span></a> <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a>) (<span class="id" title="var">t</span>: <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a>) : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a> <a class="idref" href="PnP.DepRecords.html#pcm"><span class="id" title="variable">pcm</span></a> <a class="idref" href="PnP.DepRecords.html#t"><span class="id" title="variable">t</span></a> (<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a> <a class="idref" href="PnP.DepRecords.html#pcm"><span class="id" title="variable">pcm</span></a>)<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#t"><span class="id" title="variable">t</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">case</span>: <span class="id" title="var">pcm</span>⇒<span class="id" title="var">_</span> <span class="id" title="var">join</span> <span class="id" title="var">unit</span> <span class="id" title="var">Hc</span> <span class="id" title="var">_</span> <span class="id" title="var">Hlu</span> <span class="id" title="var">_</span> <span class="id" title="var">_</span> /=.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">&nbsp;&nbsp;<a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> : <span class="id" title="keyword">Type</span><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a> : <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join"><span class="id" title="definition">join</span></a> : <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> → <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> → <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a><br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a> : <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">Hc</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#commutative"><span class="id" title="definition">commutative</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join"><span class="id" title="definition">join</span></a><br/>
&nbsp;&nbsp;<span class="id" title="var">Hlu</span> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#left_id"><span class="id" title="definition">left_id</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join"><span class="id" title="definition">join</span></a><br/>
&nbsp;&nbsp;============================<br/>
&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join"><span class="id" title="definition">join</span></a> <a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a> = <a class="idref" href="PnP.Rewriting.html#t"><span class="id" title="variable">t</span></a>
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

The first line of the proof demonstrates that dependent records in Coq
are actually just product types in disguise, so the proofs about them
should be done by case analysis. In this particular case, we decompose
the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.pcm"><span class="id" title="abbreviation">pcm</span></a></span> argument of the lemma into its components, replacing those
of no interest with wildcards <span class="inlinecode"><span class="id" title="var">_</span></span>. The <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join"><span class="id" title="definition">join</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a></span>, therefore,
bind the operation and the identity element, whereas <span class="inlinecode"><span class="id" title="var">Hc</span></span> and <span class="inlinecode"><span class="id" title="var">Hlu</span></span>
are the commutativity and left-unit properties, named explicitly in
the scope of the proof. The trailing Ssreflect's simplification
tactical  replaces the calls to the getters in
the goal (e.g., <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.pcm"><span class="id" title="abbreviation">pcm</span></a></span>) by the bound identifiers. The proof can
be now accomplished by a series of rewritings by the <span class="inlinecode"><span class="id" title="var">Hc</span></span> and <span class="inlinecode"><span class="id" title="var">Hlu</span></span>
hypotheses.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> <span class="id" title="var">Hc</span> <span class="id" title="var">Hlu</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab65"></a><h2 class="section">An alternative definition</h2>


<div class="paragraph"> </div>

In the previous section we have seen how to define the algebraic
structure of PCMs using Coq's dependent record mechanism. The same PCM
structure could be alternatively defined using the familiar syntax for
inductive types, as a datatype with precisely one constructor:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Inductive</span> <a name="DepRecords.PCMDef.mixin_of'"><span class="id" title="inductive">mixin_of'</span></a> (<span class="id" title="var">T</span>: <span class="id" title="keyword">Type</span>) := <br/>
&nbsp;&nbsp;<a name="DepRecords.PCMDef.Mixin'"><span class="id" title="constructor">Mixin'</span></a> (<span class="id" title="var">valid_op</span>: <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a>) (<span class="id" title="var">join_op</span> : <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a>) (<span class="id" title="var">unit_op</span>: <a class="idref" href="PnP.DepRecords.html#T"><span class="id" title="variable">T</span></a>) <span class="id" title="keyword">of</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#commutative"><span class="id" title="definition">commutative</span></a> <a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="variable">join_op</span></a> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#associative"><span class="id" title="definition">associative</span></a> <a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="variable">join_op</span></a> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#left_id"><span class="id" title="definition">left_id</span></a> <a class="idref" href="PnP.DepRecords.html#unit_op"><span class="id" title="variable">unit_op</span></a> <a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="variable">join_op</span></a> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">∀</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span>, <a class="idref" href="PnP.DepRecords.html#valid_op"><span class="id" title="variable">valid_op</span></a> (<a class="idref" href="PnP.DepRecords.html#join_op"><span class="id" title="variable">join_op</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#valid_op"><span class="id" title="variable">valid_op</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> &amp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#valid_op"><span class="id" title="variable">valid_op</span></a> <a class="idref" href="PnP.DepRecords.html#unit_op"><span class="id" title="variable">unit_op</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Although this definition seems more principled and is closer to what
we have seen in previous chapters, the record notation is more
convenient in this case, as it defined getters automatically as well
as allows one to express inheritance between data structures by means
of the coercion operator 
operator.

<div class="paragraph"> </div>

<a name="lab66"></a><h2 class="section">Packaging the structure from mixins</h2>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="DepRecords.PCMDef.Packing"><span class="id" title="section">Packing</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>

By now, we have defined a structure of a PCM "interface" in a form of
a set of the components (i.e., the carrier set and operations on it)
and their properties. However, it might be the case that the same
carrier set (which we represented by the type parameter <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>), should
be given properties from other algebraic data structures (e.g.,
lattices), which are essentially orthogonal to those of a
PCM. Moreover, at some point one might be interested in implementing
the proper inheritance of the PCM structure with respect to the
carrier type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>. More precisely, if the type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> comes with some
additional operations, they should be available from it, even if it's
seen as being "wrapped" into the PCM structure. That said, if <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> is
proven to be a PCM, one should be able to use this fact as well as the
functions, defined on <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> separately.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

These two problems, namely, (a) combining together several structures
into one, and (b) implementing inheritance and proper mix-in
composition, can be done in Coq using the description pattern, known
as "packed classes". The idea of the
approach is to define a "wrapper" record type, which would "pack"
several mix-ins together, similar to how it is done in object-oriented
languages with implicit trait composition, e.g.,
Scala.

<div class="paragraph"> </div>




</div>
<div class="code">

<br/>
<span class="id" title="keyword">Structure</span> <a name="DepRecords.PCMDef.pack_type"><span class="id" title="record">pack_type</span></a> : <span class="id" title="keyword">Type</span> := <a name="DepRecords.PCMDef.Pack"><span class="id" title="constructor">Pack</span></a> {<a name="DepRecords.PCMDef.type"><span class="id" title="projection">type</span></a> : <span class="id" title="keyword">Type</span>; <span class="id" title="var">_</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.mixin_of"><span class="id" title="record">mixin_of</span></a> <a class="idref" href="PnP.DepRecords.html#type"><span class="id" title="method">type</span></a>}.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The dependent data structure <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a></span> declares two fields: the
field <span class="inlinecode"><span class="id" title="keyword">type</span></span> of type <span class="inlinecode"><span class="id" title="keyword">Type</span></span>, which described the carrier type of the
PCM instance, and the actual PCM structure (without an explicit name
given) of type (<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a></span> <span class="inlinecode"><span class="id" title="keyword">type</span></span>). That is, in order to construct an
instance of <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a></span>, one will have to provide <i>both</i> arguments:
the carrier set and a PCM structure for it.

<div class="paragraph"> </div>

Next, we specify that the field <span class="inlinecode"><span class="id" title="keyword">type</span></span> of the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a></span> should be
also considered as a <i>coercion</i>, that is, whenever we have a value of
type <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a></span>, whose field <span class="inlinecode"><span class="id" title="keyword">type</span></span> is some <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>, it can be implicitly
seen as an element of type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>. The coercion is specified locally, so
it will work only in the scope of the current section (i.e.,
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Packing"><span class="id" title="section">Packing</span></a></span>) by using Coq's <span class="inlinecode"><span class="id" title="keyword">Local</span></span> <span class="inlinecode"><span class="id" title="keyword">Coercion</span></span> command. We address the
reader to Chapter 18 of the Coq Reference Manual
for more details of the implicit coercions.

<div class="paragraph"> </div>



</div>
<div class="code">

<br/>
<span class="id" title="keyword">Local</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">Coercion</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">type</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">:</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">pack_type</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">Sortclass</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>

The <span class="inlinecode">&gt;-&gt;</span> simply specifies the fact of the coercion, whereas
<span class="inlinecode"><span class="id" title="var">Sortclass</span></span> is an abstract class of sorts, so the whole command
postulates that whenever an instance of <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a></span> should be coerced
into an element of an arbitrary sort, it should be done via referring
to is <span class="inlinecode"><span class="id" title="keyword">type</span></span> field.

<div class="paragraph"> </div>

Next, in the same section, we provide a number of abbreviations to
simplify the work with the PCM packed structure and prepare it to be
exported by clients.

<div class="paragraph"> </div>


</div>
<div class="code">
<span class="id" title="keyword">Variable</span> <a name="DepRecords.PCMDef.Packing.cT"><span class="id" title="variable">cT</span></a>: <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.pack_type"><span class="id" title="record">pack_type</span></a>.<br/>

<br/>
<span class="id" title="keyword">Definition</span> <a name="DepRecords.PCMDef.pcm_struct"><span class="id" title="definition">pcm_struct</span></a> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.mixin_of"><span class="id" title="record">mixin_of</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Packing.cT"><span class="id" title="variable">cT</span></a> := <br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" title="keyword">let</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Pack"><span class="id" title="constructor">Pack</span></a> <span class="id" title="var">_</span> <span class="id" title="var">c</span> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Packing.cT"><span class="id" title="variable">cT</span></a> <span class="id" title="keyword">return</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.mixin_of"><span class="id" title="record">mixin_of</span></a> <a class="idref" href="PnP.DepRecords.html#cT"><span class="id" title="variable">cT</span></a> <span class="id" title="tactic">in</span> <span class="id" title="var">c</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The function <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.pcm_struct"><span class="id" title="definition">pcm_struct</span></a></span> extracts the PCM structure from the "packed"
instance. Notice the use of dependent pattern matching
 in the <span class="inlinecode"><span class="id" title="keyword">let</span>:</span>-statement with the
explicit <span class="inlinecode"><span class="id" title="keyword">return</span></span>-statement, so Coq would be able to refine the result
of the whole expression basing on the dependent type of the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a></span>
component of the data structure <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Packing.cT"><span class="id" title="variable">cT</span></a></span>, which is being scrutinized. With
the help of this definition, we can now define three aliases for the
PCM's key components, "lifted" to the packed data structure.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="DepRecords.PCMDef.valid"><span class="id" title="definition">valid</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.valid_op"><span class="id" title="projection">valid_op</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.pcm_struct"><span class="id" title="definition">pcm_struct</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="DepRecords.PCMDef.join"><span class="id" title="definition">join</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join_op"><span class="id" title="projection">join_op</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.pcm_struct"><span class="id" title="definition">pcm_struct</span></a>.<br/>
<span class="id" title="keyword">Definition</span> <a name="DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit_op"><span class="id" title="projection">unit_op</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.pcm_struct"><span class="id" title="definition">pcm_struct</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Packing"><span class="id" title="section">Packing</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Now, as the packaging mechanism and the aliases are properly defined,
we come to the last step of the PCM package description: preparing the
batch of definitions, notations and facts to be exported to the
client. Following the pattern of nesting modules, presented in
, we put all the entities to be exported
into the inner module <span class="inlinecode"><span class="id" title="var">Exports</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="DepRecords.PCMDef.Exports"><span class="id" title="module">Exports</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.PCMDef.Exports.pcm"><span class="id" title="abbreviation">pcm</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.pack_type"><span class="id" title="record">pack_type</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.PCMDef.Exports.PCMMixin"><span class="id" title="abbreviation">PCMMixin</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Mixin"><span class="id" title="constructor">Mixin</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.PCMDef.Exports.PCM"><span class="id" title="abbreviation">PCM</span></a> <span class="id" title="var">T</span> <span class="id" title="var">m</span> := (@<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Pack"><span class="id" title="constructor">Pack</span></a> <span class="id" title="var">T</span> <span class="id" title="var">m</span>).<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">&quot;</span></a>x \+ y" := (<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.join"><span class="id" title="definition">join</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>) (<span class="id" title="tactic">at</span> <span class="id" title="keyword">level</span> 43, <span class="id" title="tactic">left</span> <span class="id" title="keyword">associativity</span>).<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.valid"><span class="id" title="definition">valid</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.unit"><span class="id" title="definition">unit</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

We will have to define the coercion from the PCM structure with
respect to its <span class="inlinecode"><span class="id" title="keyword">type</span></span> field once again, as the previous one was
defined locally for the section <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Packing"><span class="id" title="section">Packing</span></a></span>, and, hence, is invisible in
this submodule.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">type</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">:</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">pack_type</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.type"><span class="id" title="projection">Sortclass</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab67"></a><h1 class="section">Properties of partial commutative monoids</h1>


<div class="paragraph"> </div>

Before we close the <span class="inlinecode"><span class="id" title="var">Exports</span></span> module of the <span class="inlinecode"><span class="id" title="var">PCMDef</span></span> package, it makes
sense to supply as many properties to the clients, as it will be
necessary for them to build the reasoning involving PCMs. In the
traditions of proper encapsulation,  requiring
to expose only the relevant and as abstract as possible elements of
the interface to its clients, it is undesirable for users of the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.pcm"><span class="id" title="abbreviation">pcm</span></a></span>
datatype to perform any sort of analysis on the structure of the
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a></span> datatype, as it will lead to rather tedious and cumbersome
proofs, which will first become a subject of massive changes, once we
decide to change the implementation of the PCM mixin structure.

<div class="paragraph"> </div>

This is why in this section we supply a number of properties of PCM
elements and operations, derived from its structure, which we observe
to be enough to build the reasoning with arbitrary PCM instances.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="DepRecords.PCMDef.Exports.PCMLemmas"><span class="id" title="section">PCMLemmas</span></a>.<br/>
<span class="id" title="keyword">Variable</span> <a name="DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.pcm"><span class="id" title="abbreviation">pcm</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

For instance, the following lemma re-establishes the commutativity of
the <span class="inlinecode">\+</span> operation:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.joinC"><span class="id" title="lemma">joinC</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span>⇒ <span class="id" title="var">tp</span> [<span class="id" title="var">v</span> <span class="id" title="var">j</span> <span class="id" title="var">z</span> <span class="id" title="var">Cj</span> *]; <span class="id" title="tactic">apply</span> <span class="id" title="var">Cj</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Notice that in order to make the proof to go through, we had to "push"
the PCM elements <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> to be the assumption of the goal before
case-analysing on <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a></span>. This is due to the fact that the structure of
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a></span> affects the type of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span>, therefore destructing it by means
of <span class="inlinecode"><span class="id" title="tactic">case</span></span> would change the representation of <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span> as well,
doing some rewriting and simplifications. Therefore, when <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a></span> is being
decomposed, all values, whose type depends on it (i.e., <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a></span>)
should be in the scope of decomposition. The naming pattern  helped
us to give automatic names to all remaining assumptions, appearing
from decomposition of <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a></span>'s second component before moving it to the
context before finishing the proof by applying the commutativity
"field" <span class="inlinecode"><span class="id" title="var">Cj</span></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.joinA"><span class="id" title="lemma">joinA</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>⇒<span class="id" title="var">tp</span> [<span class="id" title="var">v</span> <span class="id" title="var">j</span> <span class="id" title="var">z</span> <span class="id" title="var">Cj</span> <span class="id" title="var">Aj</span> *]; <span class="id" title="tactic">apply</span>: <span class="id" title="var">Aj</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

 
Prove the rest of the PCM laws.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.joinAC"><span class="id" title="lemma">joinAC</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.joinCA"><span class="id" title="lemma">joinCA</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">(</span></a><a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a><a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">)</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.validL"><span class="id" title="lemma">validL</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> (<a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.validR"><span class="id" title="lemma">validR</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> (<a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.unitL"><span class="id" title="lemma">unitL</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">(</span></a>@<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a><a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">)</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.unitR"><span class="id" title="lemma">unitR</span></a> (<span class="id" title="var">x</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>) : <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">(</span></a>@<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a><a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a>.<br/>

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.PCMDef.Exports.valid_unit"><span class="id" title="lemma">valid_unit</span></a> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> (@<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.Unit"><span class="id" title="abbreviation">Unit</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas"><span class="id" title="section">PCMLemmas</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports"><span class="id" title="module">Exports</span></a>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef"><span class="id" title="module">PCMDef</span></a>.<br/>

<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">PCMDef.Exports</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab68"></a><h1 class="section">Implementing inheritance hierarchies</h1>


<div class="paragraph"> </div>



<div class="paragraph"> </div>

By packaging an arbitrary type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> into one record with the PCM
structure in  and supplying it with a
specific implicit coercion, we have already achieved some degree of
inheritance: any element of a PCM can be also perceived by the system
in an appropriate context, as an element of its carrier type. 

<div class="paragraph"> </div>

In this section, we will go even further and show how to build
hierarchies of mathematical structures using the same way of encoding
inheritance. We will use a <i>cancellative PCM</i> as a running example.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Module</span> <a name="DepRecords.CancelPCM"><span class="id" title="module">CancelPCM</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

PCMs with cancellation  extend ordinary PCMs
with an extra property, that states that the equality  for any ,  and , whenever  is defined,
implies . We express such property via an additional mixin
record type, parametrized over an arbitrary PCM <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Record</span> <a name="DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a> (<span class="id" title="var">U</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.pcm"><span class="id" title="abbreviation">pcm</span></a>) := <a name="DepRecords.CancelPCM.Mixin"><span class="id" title="constructor">Mixin</span></a> {<br/>
&nbsp;&nbsp;<span class="id" title="var">_</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>: <a class="idref" href="PnP.DepRecords.html#U"><span class="id" title="variable">U</span></a>, <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> (<a class="idref" href="PnP.DepRecords.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#b"><span class="id" title="variable">b</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#a"><span class="id" title="variable">a</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#c"><span class="id" title="variable">c</span></a><br/>
}.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Notice that the validity of the sum <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> <span class="inlinecode">\+</span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a></span> is not imposed, as it can
be proven from propositional equality and the validity of <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> <span class="inlinecode">\+</span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a></span>.

<div class="paragraph"> </div>

We continue the definition by describing the standard packaging data
structure.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Structure</span> <a name="DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a> : <span class="id" title="keyword">Type</span> := <a name="DepRecords.CancelPCM.Pack"><span class="id" title="constructor">Pack</span></a> {<a name="DepRecords.CancelPCM.pcmT"><span class="id" title="projection">pcmT</span></a> : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.pcm"><span class="id" title="abbreviation">pcm</span></a>; <span class="id" title="var">_</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a> <a class="idref" href="PnP.DepRecords.html#pcmT"><span class="id" title="method">pcmT</span></a>}.<br/>

<br/>
<span class="id" title="keyword">Module</span> <a name="DepRecords.CancelPCM.Exports"><span class="id" title="module">Exports</span></a>.<br/>

<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.CancelPCM.Exports.cancel_pcm"><span class="id" title="abbreviation">cancel_pcm</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.CancelPCM.Exports.CancelPCMMixin"><span class="id" title="abbreviation">CancelPCMMixin</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Mixin"><span class="id" title="constructor">Mixin</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <a name="DepRecords.CancelPCM.Exports.CancelPCM"><span class="id" title="abbreviation">CancelPCM</span></a> <span class="id" title="var">T</span> <span class="id" title="var">m</span>:= (@<a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Pack"><span class="id" title="constructor">Pack</span></a> <span class="id" title="var">T</span> <span class="id" title="var">m</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

There is a tiny twist in the definition of the specific coercion,
though, as now we it specifies that the instance of the packed data
structure, describing the cancellative PCM, can be seen as an instance
of the underlying PCM. The coercions are transitive, which means that
the same instance can be coerced even further to <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMLemmas.U"><span class="id" title="variable">U</span></a></span>'s carrier type
<span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Coercion</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pcmT"><span class="id" title="projection">pcmT</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pcmT"><span class="id" title="projection">:</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pcmT"><span class="id" title="projection">pack_type</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pcmT"><span class="id" title="projection">&gt;-&gt;</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pcmT"><span class="id" title="projection">pcm</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

We finish the definition of the cancellative PCM by providing its only
important law, which is a direct consequence of the newly added
property.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.CancelPCM.Exports.cancel"><span class="id" title="lemma">cancel</span></a> (<span class="id" title="var">U</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Exports.cancel_pcm"><span class="id" title="abbreviation">cancel_pcm</span></a>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>: <a class="idref" href="PnP.DepRecords.html#U"><span class="id" title="variable">U</span></a>): <br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a> (<a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">case</span>: <span class="id" title="var">U</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>⇒<span class="id" title="var">Up</span> [<span class="id" title="var">Hc</span>] <span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span>; <span class="id" title="tactic">apply</span>: <span class="id" title="var">Hc</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Exports"><span class="id" title="module">Exports</span></a>.<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM"><span class="id" title="module">CancelPCM</span></a>.<br/>

<br/>
<span class="id" title="keyword">Export</span> <span class="id" title="var">CancelPCM.Exports</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The proof of the following lemma, combining commutativity and
cancellativity, demonstrates how the properties of a cancellative PCM
work in combination with the properties of its base PCM structure.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.cancelC"><span class="id" title="lemma">cancelC</span></a> (<span class="id" title="var">U</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.cancel_pcm"><span class="id" title="abbreviation">cancel_pcm</span></a>) (<span class="id" title="var">x</span> <span class="id" title="var">y</span> <span class="id" title="var">z</span> : <a class="idref" href="PnP.DepRecords.html#U"><span class="id" title="variable">U</span></a>) :<br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.valid"><span class="id" title="abbreviation">valid</span></a> (<a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a>) <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#z"><span class="id" title="variable">z</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">move</span>/<a class="idref" href="PnP.DepRecords.html#DepRecords.validL"><span class="id" title="lemma">validL</span></a>; <span class="id" title="tactic">rewrite</span> ![<span class="id" title="var">y</span> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <span class="id" title="var">_</span>]<a class="idref" href="PnP.DepRecords.html#DepRecords.joinC"><span class="id" title="lemma">joinC</span></a>; <span class="id" title="tactic">apply</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.cancel"><span class="id" title="lemma">cancel</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<a name="lab69"></a><h1 class="section">Instantiation and canonical structures</h1>


<div class="paragraph"> </div>

Now, as we have defined a PCM structure along with its specialized
version, a cancellative PCM, it is time to see how to <i>instantiate</i>
these abstract definitions with concrete datatypes, i.e., <i>prove</i> the
latter ones to be instances of a PCM.

<div class="paragraph"> </div>



<div class="paragraph"> </div>

<a name="lab70"></a><h2 class="section">Defining arbitrary PCM instances</h2>


<div class="paragraph"> </div>

Natural numbers form a PCM, in particular, with addition as a join
operation and zero as a unit element. The validity predicate is
constant true, because the addition of two natural numbers is again a
valid natural number. Therefore, we can instantiate the PCM structure
for <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> as follows, first by constructing the appropriate mixin.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="DepRecords.natPCMMixin"><span class="id" title="definition">natPCMMixin</span></a> := <br/>
&nbsp;&nbsp;<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMMixin"><span class="id" title="abbreviation">PCMMixin</span></a> <span class="id" title="lemma">addnC</span> <span class="id" title="lemma">addnA</span> <span class="id" title="lemma">add0n</span> (<span class="id" title="keyword">fun</span> <span class="id" title="var">x</span> <span class="id" title="var">y</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#481b7e18e0f4d27d48ec2e56a543d475"><span class="id" title="notation">@</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#481b7e18e0f4d27d48ec2e56a543d475"><span class="id" title="notation">id</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a>) (<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#erefl"><span class="id" title="abbreviation">erefl</span></a> <span class="id" title="var">_</span>).<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The constructor <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCMMixin"><span class="id" title="abbreviation">PCMMixin</span></a></span>, defined in 
is invoked with five parameters, all of which correspond to the
properties, ensured by the PCM definition. The rest of the arguments,
namely, the validity predicate, the join operation and the zero
element are implicit and are soundly inferred by Coq's type inference
engine from the types of lemmas, provided as propositional
arguments. For instance, the first argument <span class="inlinecode"><a class="idref" href="PnP.Rewriting.html#Rewriting.addnC"><span class="id" title="lemma">addnC</span></a></span>, whose type is
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrfun.html#commutative"><span class="id" title="definition">commutative</span></a></span> <span class="inlinecode"><span class="id" title="var">addn</span></span> makes it possible to infer that the join operation
is the addition. In the same spirit, the third argument, <span class="inlinecode"><span class="id" title="lemma">add0n</span></span> makes
it unambiguous that the unit element is zero.

<div class="paragraph"> </div>

After defining the PCM mixin, we can instantiate the PCM packed class
for <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> by the following definition:

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="DepRecords.NatPCM"><span class="id" title="definition">NatPCM</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCM"><span class="id" title="abbreviation">PCM</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.natPCMMixin"><span class="id" title="definition">natPCMMixin</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

This definition will indeed work, although, being somewhat
unsatisfactory. For example, assume we want to prove the following
lemma for natural numbers treated as elements of a PCM, which should
trivially follow from the PCM properties of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> with addition and
zero:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Lemma</span> <span class="id" title="var">add_perm</span> (<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a> : <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>) : <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> \+ (<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a> \+ <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a>) = <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> \+ (<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a> \+ <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a>).
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">The</span> <span class="id" title="var">term</span> "a" <span class="id" title="var">has</span> <span class="id" title="keyword">type</span> "nat" <span class="id" title="var">while</span> <span class="id" title="var">it</span> <span class="id" title="keyword">is</span> <span class="id" title="var">expected</span> <span class="id" title="var">to</span> <span class="id" title="var">have</span> <span class="id" title="keyword">type</span> "PCMDef.type ?135".
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

This error is due to the fact that Coq is unable to recognize natural
numbers to be elements of the corresponding PCM, and one possible way
to fix it is to declare the parameters of the lemma <span class="inlinecode"><span class="id" title="var">add_perm</span></span>, <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span>,
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a></span> and <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a></span> to be of type <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.NatPCM"><span class="id" title="definition">NatPCM</span></a></span> rather than <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>. This is still
awkward: it means that the lemmas cannot be just applied to mere
natural numbers, instead they need to be <i>coerced</i> to the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.NatPCM"><span class="id" title="definition">NatPCM</span></a></span>
type explicitly whenever we need to apply this lemma. Coq suggests a
better solution to this problem by providing a mechanism of <i>canonical
structures</i> as a flexible way to specify <i>how exactly</i> each concrete
datatype should be embedded into an abstract mathematical
structure.

<div class="paragraph"> </div>

 

<div class="paragraph"> </div>

The Vernacular syntax for defining canonical structures is similar to
the one of definitions and makes use of the 
command.
The following definition defines <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.natPCM"><span class="id" title="definition">natPCM</span></a></span> to be a canonical instance
of the PCM structure for natural numbers.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">natPCM</span> := <a class="idref" href="PnP.DepRecords.html#DepRecords.PCM"><span class="id" title="abbreviation">PCM</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.natPCMMixin"><span class="id" title="definition">natPCMMixin</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

To see what kind of effect it takes, we will print all <i>canonical
projections</i>, currently available in the context of the module. 

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Print</span> <span class="id" title="var">Canonical</span> <span class="id" title="var">Projections</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

<br/>
<span class="inlinecode">...<br/>
<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> &lt;- <span class="id" title="var">PCMDef.type</span> ( <a class="idref" href="PnP.DepRecords.html#DepRecords.natPCM"><span class="id" title="definition">natPCM</span></a> )<br/>
<span class="id" title="var">pred_of_mem</span> &lt;- <span class="id" title="var">topred</span> ( <span class="id" title="var">memPredType</span> )<br/>
<span class="id" title="var">pred_of_simpl</span> &lt;- <span class="id" title="var">topred</span> ( <span class="id" title="var">simplPredType</span> )<br/>
<span class="id" title="var">sig</span> &lt;- <span class="id" title="var">sub_sort</span> ( <span class="id" title="var">sig_subType</span> )<br/>
<span class="id" title="var">number</span> &lt;- <span class="id" title="var">sub_sort</span> ( <span class="id" title="var">number_subType</span> )<br/>
...
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


The displayed list enumerates all <i>canonical projections</i> that specify,
which implicit canonical instances are currently available and will be
picked implicitly for appropriate types (on the left of the arrow
<span class="inlinecode">&lt;-</span>). That is, for example, whenever an instance of <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> is
available, but in fact it should be treated as the <span class="inlinecode"><span class="id" title="keyword">type</span></span> field of the
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCM"><span class="id" title="abbreviation">PCM</span></a></span> structure (with all getters typed properly), the canonical
instance <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.natPCM"><span class="id" title="definition">natPCM</span></a></span> will be automatically picked by Coq for such
embedding. In other words, the machinery of canonical structures
allows us to define the policy for finding an appropriate <i>dictionary</i>
of functions and propositions for an arbitrary concrete datatype,
whenever it is supposed to have them. In fact, upon declaring the
canonical structure <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.natPCM"><span class="id" title="definition">natPCM</span></a></span>, the canonical projections are
registered by Coq for all <i>named</i> fields of the record <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCM"><span class="id" title="abbreviation">PCM</span></a></span>, which is
precisely just the <span class="inlinecode"><span class="id" title="keyword">type</span></span> field, since <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCM"><span class="id" title="abbreviation">PCM</span></a></span>'s second component of
type (<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a></span> <span class="inlinecode"><span class="id" title="keyword">type</span></span>) was left unnamed (see the definition of
the record <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.pack_type"><span class="id" title="record">pack_type</span></a></span> on page).

<div class="paragraph"> </div>

The mechanism of defining canonical structures for concrete data types
is reminiscent of the resolution of type class constraints in
Haskell. However, unlike Haskell, where
the resolution algorithm for type class instances is <i>hard-coded</i>, in
the case of Coq one can actually <i>program</i> the way the canonical
instances are resolved. This leads to a very powerful
technique to automate the process of theorem proving by encoding the
way to find and apply necessary lemmas, whenever it is required. These
techniques are, however, outside of the scope of this course, so we
direct the interested reader to the relevant research papers that
describe the patterns of programming with canonical
structures.

<div class="paragraph"> </div>

Similarly to the way we have defined a canonical instance of PCM for
<span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, we can define a canonical instance of a PCM with
cancellativity. In order to instantiate it, we will, however, need to
prove the following lemma, which states that the addition on natural
numbers is indeed cancellative, so this fact will be used as an
argument for the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Exports.CancelPCMMixin"><span class="id" title="abbreviation">CancelPCMMixin</span></a></span> constructor.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.cancelNat"><span class="id" title="lemma">cancelNat</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>, <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.DepRecords.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#a"><span class="id" title="variable">a</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.DepRecords.html#c"><span class="id" title="variable">c</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#b"><span class="id" title="variable">b</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#c"><span class="id" title="variable">c</span></a>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">move</span>⇒ <span class="id" title="var">a</span> <span class="id" title="var">b</span> <span class="id" title="var">c</span>; <span class="id" title="tactic">elim</span>: <span class="id" title="var">a</span>=&gt;// <span class="id" title="var">n</span> /(<span class="id" title="var">_</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.ssr.ssrbool.html#is_true_true"><span class="id" title="lemma">is_true_true</span></a>) <span class="id" title="var">Hn</span> <span class="id" title="var">_</span> <span class="id" title="var">H</span>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">apply</span>: <span class="id" title="var">Hn</span>; <span class="id" title="tactic">rewrite</span> !<span class="id" title="lemma">addSn</span> <span class="id" title="tactic">in</span> <span class="id" title="var">H</span>; <span class="id" title="tactic">move</span>/<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Peano.html#eq_add_S"><span class="id" title="definition">eq_add_S</span></a>: <span class="id" title="var">H</span>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Notice the first assumption <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span> of the lemma. Here it serves as a
placeholder for the general validity hypothesis <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.valid"><span class="id" title="abbreviation">valid</span></a></span> <span class="inlinecode">(<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> <span class="inlinecode">\+</span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a>)</span>,
which is always <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a></span> in the case of natural numbers.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Definition</span> <a name="DepRecords.cancelNatPCMMixin"><span class="id" title="definition">cancelNatPCMMixin</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCMMixin"><span class="id" title="abbreviation">CancelPCMMixin</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.cancelNat"><span class="id" title="lemma">cancelNat</span></a>.<br/>

<br/>
<span class="id" title="keyword">Canonical</span> <span class="id" title="var">cancelNatPCM</span> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM"><span class="id" title="abbreviation">CancelPCM</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.natPCM"><span class="id" title="definition">natPCM</span></a> <a class="idref" href="PnP.DepRecords.html#DepRecords.cancelNatPCMMixin"><span class="id" title="definition">cancelNatPCMMixin</span></a>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

Let us now see the canonical instances in action, so we can prove a
number of lemmas about natural numbers employing the general PCM
machinery.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Section</span> <a name="DepRecords.PCMExamples"><span class="id" title="section">PCMExamples</span></a>.<br/>

<br/>
</div>

<div class="doc">
 
</div>
<div class="code">

<br/>
<span class="id" title="keyword">Variables</span> <a name="DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a> <a name="DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a> <a name="DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>.<br/>

<br/>
<span class="id" title="keyword">Goal</span> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">a</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">\+</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">(</span></a><a name="DepRecords.Unnamed_thm"><span class="id" title="definition">b</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">\+</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">c</span></a><a name="DepRecords.Unnamed_thm"><span class="id" title="definition">)</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">=</span></a>  <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">c</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">\+</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">(</span></a><a name="DepRecords.Unnamed_thm"><span class="id" title="definition">b</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">\+</span></a> <a name="DepRecords.Unnamed_thm"><span class="id" title="definition">a</span></a><a name="DepRecords.Unnamed_thm"><span class="id" title="definition">)</span></a>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.joinA"><span class="id" title="lemma">joinA</span></a> [<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <span class="id" title="var">_</span>]<a class="idref" href="PnP.DepRecords.html#DepRecords.joinC"><span class="id" title="lemma">joinC</span></a> [<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <span class="id" title="var">_</span>]<a class="idref" href="PnP.DepRecords.html#DepRecords.joinC"><span class="id" title="lemma">joinC</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

The next goal is proved by using the combined machinery of <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMDef.Exports.PCM"><span class="id" title="abbreviation">PCM</span></a></span> and
<span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Exports.CancelPCM"><span class="id" title="abbreviation">CancelPCM</span></a></span>.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Goal</span> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">c</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">\+</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">a</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">=</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">a</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">\+</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">b</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">→</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">c</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">=</span></a> <a name="DepRecords.Unnamed_thm0"><span class="id" title="definition">b</span></a>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">rewrite</span> [<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.c"><span class="id" title="variable">c</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <span class="id" title="var">_</span>]<a class="idref" href="PnP.DepRecords.html#DepRecords.joinC"><span class="id" title="lemma">joinC</span></a>; <span class="id" title="tactic">apply</span>: <a class="idref" href="PnP.DepRecords.html#DepRecords.cancel"><span class="id" title="lemma">cancel</span></a>.<br/>
<span class="id" title="keyword">Qed</span>.<br/>

<br/>
</div>

<div class="doc">

<div class="paragraph"> </div>

It might look a bit cumbersome, though, to write the PCM join
operation <span class="inlinecode">\+</span> instead of the boolean addition when specifying the
facts about natural numbers (even though they are treated as elements
of the appropriate PCM). Unfortunately, it is not trivial to encode
the mechanism, which will perform such conversion implicitly. Even
though Coq is capable of figuring out what PCM is necessary for a
particular type (if the necessary canonical instance is defined),
e.g., when seeing <span class="inlinecode">(<a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.a"><span class="id" title="variable">a</span></a></span> <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples.b"><span class="id" title="variable">b</span></a></span> <span class="inlinecode">:</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>)</span> being used, it infers the <span class="inlinecode"><a class="idref" href="PnP.DepRecords.html#DepRecords.natPCM"><span class="id" title="definition">natPCM</span></a></span>,
alas, it's not powerful enough to infer that by writing the
addition function <span class="inlinecode">+</span> on natural numbers, we mean the PCM's
join. However, if necessary, in most of the cases the conversion like
this can be done by manual rewriting using the following trivial
"conversion" lemma.

<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Lemma</span> <a name="DepRecords.addn_join"><span class="id" title="lemma">addn_join</span></a> (<span class="id" title="var">x</span> <span class="id" title="var">y</span>: <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a>): <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <span class="id" title="notation">+</span> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.DepRecords.html#69d432cb5661a444ee335d7c8592d74f"><span class="id" title="notation">\+</span></a> <a class="idref" href="PnP.DepRecords.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Proof</span>. <span class="id" title="tactic">by</span> []. <span class="id" title="keyword">Qed</span>.<br/>

<br/>
<span class="id" title="keyword">End</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.PCMExamples"><span class="id" title="section">PCMExamples</span></a>.<br/>

<br/>
</div>

<div class="doc">


<div class="paragraph"> </div>



<div class="paragraph"> </div>

A partially ordered set order is a pair , such that  is
a set and  is a (propositional) relation on , such that

<div class="paragraph"> </div>



<div class="paragraph"> </div>


Implement a data structure for partially-ordered sets using mixins and
packed classes. Prove the following laws:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Lemma</span> <span class="id" title="var">poset_refl</span> (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> : <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>) : <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> &lt;== <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a>.<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">poset_asym</span> (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> : <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>) : <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> &lt;== <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> → <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> &lt;== <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> → <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> = <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a>.<br/>
<span class="id" title="keyword">Lemma</span> <span class="id" title="var">poset_trans</span> (<a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#z"><span class="id" title="variable">z</span></a> : <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>) : <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> &lt;== <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> → <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a> &lt;== <a class="idref" href="PnP.LogicPrimer.html#z"><span class="id" title="variable">z</span></a> → <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> &lt;== <a class="idref" href="PnP.LogicPrimer.html#z"><span class="id" title="variable">z</span></a>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>



<div class="paragraph"> </div>



<div class="paragraph"> </div>

Provide canonical instances of partially ordered sets for the
following types:

<div class="paragraph"> </div>

<ul class="doclist">
<li> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span> with <span class="inlinecode">≤</span> as a partial order;

</li>
<li> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#prod"><span class="id" title="inductive">prod</span></a></span>, whose components are partially-ordered sets;

</li>
<li> functions <span class="inlinecode"><a class="idref" href="PnP.SsrStyle.html#SsrStyle.A"><span class="id" title="axiom">A</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span>, whose codomain (range) <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#B"><span class="id" title="variable">B</span></a></span> is a partially
  ordered set.

</li>
</ul>

<div class="paragraph"> </div>

In order to provide a canonical instance for functions, you will need
to assume and make use of the following axiom of functional
extensionality:

<div class="paragraph"> </div>



<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
<span class="id" title="keyword">Axiom</span> <a name="DepRecords.fext"><span class="id" title="axiom">fext</span></a> : <span class="id" title="keyword">∀</span> <span class="id" title="var">A</span> (<span class="id" title="var">B</span> : <a class="idref" href="PnP.DepRecords.html#A"><span class="id" title="variable">A</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <span class="id" title="keyword">Type</span>) (<span class="id" title="var">f1</span> <span class="id" title="var">f2</span> : <span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="PnP.DepRecords.html#B"><span class="id" title="variable">B</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a>), <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">(</span></a><span class="id" title="keyword">∀</span> <span class="id" title="var">x</span>, <a class="idref" href="PnP.DepRecords.html#f1"><span class="id" title="variable">f1</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#f2"><span class="id" title="variable">f2</span></a> <a class="idref" href="PnP.DepRecords.html#x"><span class="id" title="variable">x</span></a><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">)</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#1c93e43e07fbeaeb6a625cb6614beb5d"><span class="id" title="notation">→</span></a> <a class="idref" href="PnP.DepRecords.html#f1"><span class="id" title="variable">f1</span></a> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Logic.html#6cd0f7b28b6092304087c7049437bb1a"><span class="id" title="notation">=</span></a> <a class="idref" href="PnP.DepRecords.html#f2"><span class="id" title="variable">f2</span></a>.<br/>

<br/>
</div>

<div class="doc">


<div class="paragraph"> </div>

<a name="lab71"></a><h2 class="section">Types with decidable equalities</h2>



<div class="paragraph"> </div>

When working with Ssreflect and its libraries, one will always come
across multiple canonical instances of a particularly important
dependent record type---a structure with decidable equality. As it has
been already demonstrated in , for concrete
datatypes, which enjoy the decidable boolean equality <span class="inlinecode">(==)</span>, the
"switch" to Coq's propositional equality and back can be done
seamlessly by means of using the view lemma <span class="inlinecode"><span class="id" title="lemma">eqP</span></span>, leveraging the
<span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Inner.reflect"><span class="id" title="inductive">reflect</span></a></span> predicate instance of the form <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Inner.reflect"><span class="id" title="inductive">reflect</span></a></span> <span class="inlinecode">(<a class="idref" href="PnP.BoolReflect.html#b1"><span class="id" title="variable">b1</span></a></span> <span class="inlinecode">=</span> <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#b2"><span class="id" title="variable">b2</span></a>)</span> <span class="inlinecode">(<a class="idref" href="PnP.BoolReflect.html#b1"><span class="id" title="variable">b1</span></a></span> <span class="inlinecode">==</span>
<span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#b2"><span class="id" title="variable">b2</span></a>)</span>. Let us now show how the decidable equality is
defined and instantiated.

<div class="paragraph"> </div>

The module <span class="inlinecode"><span class="id" title="library">eqtype</span></span> of Ssreflect's standard library
provides a definition of the equality mixin and packaged class of the
familiar shape, which, after some simplifications, boil to the
following ones:

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Module</span> <span class="id" title="var">Equality</span>.<br/>
<br/>
<span class="id" title="keyword">Definition</span> <span class="id" title="var">axiom</span> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> (<a class="idref" href="PnP.FunProg.html#e"><span class="id" title="variable">e</span></a> : <span class="id" title="var">rel</span> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>) := <span class="id" title="keyword">∀</span> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a>, <a class="idref" href="PnP.BoolReflect.html#BoolReflect.Inner.reflect"><span class="id" title="inductive">reflect</span></a> (<a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> = <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a>) (<a class="idref" href="PnP.FunProg.html#e"><span class="id" title="variable">e</span></a> <a class="idref" href="PnP.LogicPrimer.html#x"><span class="id" title="variable">x</span></a> <a class="idref" href="PnP.LogicPrimer.html#y"><span class="id" title="variable">y</span></a>).<br/>
<br/>
<span class="id" title="keyword">Structure</span> <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Mixin"><span class="id" title="constructor">Mixin</span></a> {<span class="id" title="var">op</span> : <span class="id" title="var">rel</span> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a>; <span class="id" title="var">_</span> : <span class="id" title="var">axiom</span> <span class="id" title="var">op</span>}.<br/>
<span class="id" title="keyword">Structure</span> <span class="id" title="keyword">type</span> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Pack"><span class="id" title="constructor">Pack</span></a> {<span class="id" title="var">sort</span>; <span class="id" title="var">_</span> : <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.mixin_of"><span class="id" title="record">mixin_of</span></a> <span class="id" title="var">sort</span>}.<br/>
<br/>
...<br/>
<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">EqMixin</span> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Mixin"><span class="id" title="constructor">Mixin</span></a>.<br/>
<span class="id" title="keyword">Notation</span> <span class="id" title="var">EqType</span> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> := <a class="idref" href="PnP.DepRecords.html#DepRecords.CancelPCM.Pack"><span class="id" title="constructor">Pack</span></a> <a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>.<br/>
<br/>
<span class="id" title="keyword">End</span> <span class="id" title="var">Equality</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>

That is, the mixin for equality is a dependent record, whose first
field is a relation <span class="inlinecode"><span class="id" title="var">op</span></span> on a particular carrier type <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> (defined
internally as a function <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> <span class="inlinecode">×</span> <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span> <span class="inlinecode">→</span> <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#bool"><span class="id" title="inductive">bool</span></a></span>), and the second argument is
a proof of the definition <span class="inlinecode"><span class="id" title="var">axiom</span></span>, which postulates that the relation
is in fact equivalent to propositional equality (which is
established by means of inhabiting the <span class="inlinecode"><a class="idref" href="PnP.BoolReflect.html#BoolReflect.Inner.reflect"><span class="id" title="inductive">reflect</span></a></span> predicate
instance). Therefore, in order to make a relation <span class="inlinecode"><span class="id" title="var">op</span></span> to be a
decidable equality on <span class="inlinecode"><a class="idref" href="PnP.HTT.html#HTT.LList.T"><span class="id" title="variable">T</span></a></span>, one needs to prove that, in fact, it is
equivalent to the standard, propositional equality.

<div class="paragraph"> </div>

Subsequently, Ssreflect libraries deliver the canonical instances of
the decidable equality structure to all commonly used concrete
datatypes. For example, the decidable equality for natural numbers is
implemented in the <span class="inlinecode"><span class="id" title="library">ssrnat</span></span> module by the following
recursive function:<span class="inlinecode">{<span class="id" title="keyword">struct</span></span> <span class="inlinecode"><a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>}</span><span class="inlinecode"><span class="id" title="var">eqn</span></span>

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Fixpoint</span> <span class="id" title="var">eqn</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> {<span class="id" title="keyword">struct</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>} :=<br/>
&nbsp;&nbsp;<span class="id" title="keyword">match</span> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>, <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <span class="id" title="keyword">with</span><br/>
&nbsp;&nbsp;| 0, 0 ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#true"><span class="id" title="constructor">true</span></a><br/>
&nbsp;&nbsp;| <a class="idref" href="PnP.FunProg.html#m'"><span class="id" title="variable">m'</span></a>.+1, <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a>.+1 ⇒ <span class="id" title="var">eqn</span> <a class="idref" href="PnP.FunProg.html#m'"><span class="id" title="variable">m'</span></a> <a class="idref" href="PnP.FunProg.html#n'"><span class="id" title="variable">n'</span></a><br/>
&nbsp;&nbsp;| <span class="id" title="var">_</span>, <span class="id" title="var">_</span> ⇒ <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#false"><span class="id" title="constructor">false</span></a><br/>
&nbsp;&nbsp;<span class="id" title="keyword">end</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


The following lemma ensures that <span class="inlinecode"><span class="id" title="var">eqn</span></span> correctly reflects the
propositional equality.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="keyword">Lemma</span> <span class="id" title="lemma">eqnP</span> : <span class="id" title="var">Equality.axiom</span> <span class="id" title="var">eqn</span>.<br/>
<span class="id" title="keyword">Proof</span>.<br/>
<span class="id" title="tactic">move</span>⇒ <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a>; <span class="id" title="tactic">apply</span>: (<span class="id" title="var">iffP</span> <span class="id" title="var">idP</span>) ⇒ [ | &lt;- ]; <span class="id" title="var">last</span> <span class="id" title="tactic">by</span> <span class="id" title="tactic">elim</span> <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a>.<br/>
<span class="id" title="tactic">by</span> <span class="id" title="tactic">elim</span>: <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ⇒ [ | <a class="idref" href="PnP.FunProg.html#NatUtilSection.n"><span class="id" title="variable">n</span></a> <span class="id" title="var">IHn</span>] [| <a class="idref" href="PnP.FunProg.html#m"><span class="id" title="variable">m</span></a> ] //= /<span class="id" title="var">IHn</span> →.<br/>
<span class="id" title="keyword">Qed</span>.
<div class="paragraph"> </div>

</span>

<div class="paragraph"> </div>


Finally, the following two definitions establish the canonical instance
of the decidable equality for <span class="inlinecode"><a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a></span>, which can be used whenever
<span class="inlinecode"><span class="id" title="library">ssrnat</span></span> is imported.

<div class="paragraph"> </div>

<br/>
<span class="inlinecode"><span class="id" title="var">Canonical</span> <span class="id" title="var">nat_eqMixin</span> := <span class="id" title="var">EqMixin</span> <span class="id" title="lemma">eqnP</span>.<br/>
<span class="id" title="var">Canonical</span> <span class="id" title="var">nat_eqType</span> := <span class="id" title="var">EqType</span> <a class="idref" href="http://coq.inria.fr/distrib/V8.11.0/stdlib//Coq.Init.Datatypes.html#nat"><span class="id" title="inductive">nat</span></a> <span class="id" title="var">nat_eqMixin</span>.
<div class="paragraph"> </div>

</span>
<div class="paragraph"> </div>


</div>
<div class="code">

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr/">coqdoc</a>
</div>

</div>

</body>
<script src="https://jscoq.github.io/node_modules/jscoq/ui-js/jscoq-loader.js" type="text/javascript"></script>
<script src="../js/jscoq-embed.js" type="text/javascript"></script>
</html>
